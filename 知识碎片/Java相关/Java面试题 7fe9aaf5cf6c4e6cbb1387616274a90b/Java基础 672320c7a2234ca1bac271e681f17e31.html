<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础 | lin</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <meta name="description" content="记录进步的点滴">
    <meta property="og:site_name" content="lin">
    <meta property="og:title" content="Java基础">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://bigdragonlin.github.io/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/Java%E9%9D%A2%E8%AF%95%E9%A2%98%207fe9aaf5cf6c4e6cbb1387616274a90b/Java%E5%9F%BA%E7%A1%80%20672320c7a2234ca1bac271e681f17e31.html">
    <meta name="twitter:title" content="Java基础">
    <meta name="twitter:url" content="https://bigdragonlin.github.io/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/Java%E9%9D%A2%E8%AF%95%E9%A2%98%207fe9aaf5cf6c4e6cbb1387616274a90b/Java%E5%9F%BA%E7%A1%80%20672320c7a2234ca1bac271e681f17e31.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="程序员, 编程, 计算机">
    <meta property="article:tag" content="程序员">
    <meta name="keywords" content="编程学习路线, 编程知识百科, Java, 编程导航, 前端, 开发, 编程分享, 项目, IT, 求职, 面经">
    
    <link rel="preload" href="/assets/css/0.styles.dd3f1dd5.css" as="style"><link rel="preload" href="/assets/js/app.ca6810f0.js" as="script"><link rel="preload" href="/assets/js/1.a7899151.js" as="script"><link rel="preload" href="/assets/js/67.dc48310c.js" as="script"><link rel="prefetch" href="/assets/js/10.8111f976.js"><link rel="prefetch" href="/assets/js/100.c3d9648c.js"><link rel="prefetch" href="/assets/js/101.31bd77ed.js"><link rel="prefetch" href="/assets/js/102.75748718.js"><link rel="prefetch" href="/assets/js/103.fefc26c8.js"><link rel="prefetch" href="/assets/js/104.6833bd21.js"><link rel="prefetch" href="/assets/js/105.2a44ef65.js"><link rel="prefetch" href="/assets/js/106.b085d75e.js"><link rel="prefetch" href="/assets/js/107.d43eadfd.js"><link rel="prefetch" href="/assets/js/108.a82c88db.js"><link rel="prefetch" href="/assets/js/109.43567b2e.js"><link rel="prefetch" href="/assets/js/11.675ae2e2.js"><link rel="prefetch" href="/assets/js/110.e9b76f2e.js"><link rel="prefetch" href="/assets/js/111.228eb17e.js"><link rel="prefetch" href="/assets/js/112.16977eac.js"><link rel="prefetch" href="/assets/js/113.bf85006c.js"><link rel="prefetch" href="/assets/js/114.1feafc0d.js"><link rel="prefetch" href="/assets/js/115.27c63cfd.js"><link rel="prefetch" href="/assets/js/116.6b258b63.js"><link rel="prefetch" href="/assets/js/117.2a4ea694.js"><link rel="prefetch" href="/assets/js/118.14319035.js"><link rel="prefetch" href="/assets/js/119.b45026b0.js"><link rel="prefetch" href="/assets/js/12.611fe139.js"><link rel="prefetch" href="/assets/js/120.f3eada75.js"><link rel="prefetch" href="/assets/js/121.d5813ad6.js"><link rel="prefetch" href="/assets/js/122.203b5e6a.js"><link rel="prefetch" href="/assets/js/123.8c4f7397.js"><link rel="prefetch" href="/assets/js/124.04cff09e.js"><link rel="prefetch" href="/assets/js/125.05b77e9b.js"><link rel="prefetch" href="/assets/js/126.385ad5db.js"><link rel="prefetch" href="/assets/js/127.5c05acb6.js"><link rel="prefetch" href="/assets/js/128.acc58546.js"><link rel="prefetch" href="/assets/js/129.e9e12ec9.js"><link rel="prefetch" href="/assets/js/13.bbcb9761.js"><link rel="prefetch" href="/assets/js/130.eb6bd4fc.js"><link rel="prefetch" href="/assets/js/131.77bc5ddd.js"><link rel="prefetch" href="/assets/js/132.a696f9a5.js"><link rel="prefetch" href="/assets/js/133.bd92160a.js"><link rel="prefetch" href="/assets/js/134.92264011.js"><link rel="prefetch" href="/assets/js/135.9a1d9b8a.js"><link rel="prefetch" href="/assets/js/136.e3f55bc9.js"><link rel="prefetch" href="/assets/js/137.38a53ca5.js"><link rel="prefetch" href="/assets/js/138.9af220ba.js"><link rel="prefetch" href="/assets/js/139.2ea1d0aa.js"><link rel="prefetch" href="/assets/js/14.27da1495.js"><link rel="prefetch" href="/assets/js/140.f24895fe.js"><link rel="prefetch" href="/assets/js/141.8380d4d5.js"><link rel="prefetch" href="/assets/js/142.cef7432d.js"><link rel="prefetch" href="/assets/js/143.7a359979.js"><link rel="prefetch" href="/assets/js/144.d135462b.js"><link rel="prefetch" href="/assets/js/145.b6f69890.js"><link rel="prefetch" href="/assets/js/146.66faecd7.js"><link rel="prefetch" href="/assets/js/15.49e75645.js"><link rel="prefetch" href="/assets/js/16.09145204.js"><link rel="prefetch" href="/assets/js/17.6b86b1e5.js"><link rel="prefetch" href="/assets/js/18.d042910d.js"><link rel="prefetch" href="/assets/js/19.ddb3a096.js"><link rel="prefetch" href="/assets/js/2.d74f4bad.js"><link rel="prefetch" href="/assets/js/20.3ace0aa5.js"><link rel="prefetch" href="/assets/js/21.7eb1c3cc.js"><link rel="prefetch" href="/assets/js/22.cff4c035.js"><link rel="prefetch" href="/assets/js/23.07adb667.js"><link rel="prefetch" href="/assets/js/24.29d6a672.js"><link rel="prefetch" href="/assets/js/25.f83be928.js"><link rel="prefetch" href="/assets/js/26.d1712bb0.js"><link rel="prefetch" href="/assets/js/27.25530b6e.js"><link rel="prefetch" href="/assets/js/28.a340957f.js"><link rel="prefetch" href="/assets/js/29.f2754eb7.js"><link rel="prefetch" href="/assets/js/3.72a02e88.js"><link rel="prefetch" href="/assets/js/30.9ac4febe.js"><link rel="prefetch" href="/assets/js/31.1dde25cc.js"><link rel="prefetch" href="/assets/js/32.4087c135.js"><link rel="prefetch" href="/assets/js/33.7696f9d2.js"><link rel="prefetch" href="/assets/js/34.56b8aa20.js"><link rel="prefetch" href="/assets/js/35.e5dd505a.js"><link rel="prefetch" href="/assets/js/36.0906ffc8.js"><link rel="prefetch" href="/assets/js/37.4bf277b3.js"><link rel="prefetch" href="/assets/js/38.898c86e2.js"><link rel="prefetch" href="/assets/js/39.2b08ff32.js"><link rel="prefetch" href="/assets/js/4.2002c685.js"><link rel="prefetch" href="/assets/js/40.de5b4385.js"><link rel="prefetch" href="/assets/js/41.4b058022.js"><link rel="prefetch" href="/assets/js/42.d9754d64.js"><link rel="prefetch" href="/assets/js/43.3d8af8e3.js"><link rel="prefetch" href="/assets/js/44.b49601c7.js"><link rel="prefetch" href="/assets/js/45.3fb7a5e7.js"><link rel="prefetch" href="/assets/js/46.7512c87a.js"><link rel="prefetch" href="/assets/js/47.69f52a8d.js"><link rel="prefetch" href="/assets/js/48.48367446.js"><link rel="prefetch" href="/assets/js/49.154237f1.js"><link rel="prefetch" href="/assets/js/5.ed8fd711.js"><link rel="prefetch" href="/assets/js/50.2d51489f.js"><link rel="prefetch" href="/assets/js/51.e3e48a00.js"><link rel="prefetch" href="/assets/js/52.71319e9d.js"><link rel="prefetch" href="/assets/js/53.76670559.js"><link rel="prefetch" href="/assets/js/54.b2a18c59.js"><link rel="prefetch" href="/assets/js/55.a206441f.js"><link rel="prefetch" href="/assets/js/56.602248d0.js"><link rel="prefetch" href="/assets/js/57.163afc2d.js"><link rel="prefetch" href="/assets/js/58.a2057559.js"><link rel="prefetch" href="/assets/js/59.3c0e4c86.js"><link rel="prefetch" href="/assets/js/6.a237149d.js"><link rel="prefetch" href="/assets/js/60.9d8d9dbc.js"><link rel="prefetch" href="/assets/js/61.b3811e77.js"><link rel="prefetch" href="/assets/js/62.5d38f7cd.js"><link rel="prefetch" href="/assets/js/63.264e91fb.js"><link rel="prefetch" href="/assets/js/64.4b55aee3.js"><link rel="prefetch" href="/assets/js/65.09c20b34.js"><link rel="prefetch" href="/assets/js/66.0fc1c46a.js"><link rel="prefetch" href="/assets/js/68.5d8c23b0.js"><link rel="prefetch" href="/assets/js/69.03cbc1c9.js"><link rel="prefetch" href="/assets/js/7.b3d59ec2.js"><link rel="prefetch" href="/assets/js/70.b2a017c1.js"><link rel="prefetch" href="/assets/js/71.da6e8dd0.js"><link rel="prefetch" href="/assets/js/72.679cfcfc.js"><link rel="prefetch" href="/assets/js/73.302bc7b7.js"><link rel="prefetch" href="/assets/js/74.f47f2a86.js"><link rel="prefetch" href="/assets/js/75.0435670f.js"><link rel="prefetch" href="/assets/js/76.aaca7275.js"><link rel="prefetch" href="/assets/js/77.1b271da3.js"><link rel="prefetch" href="/assets/js/78.476a924e.js"><link rel="prefetch" href="/assets/js/79.23be6cff.js"><link rel="prefetch" href="/assets/js/80.d592bdd2.js"><link rel="prefetch" href="/assets/js/81.461bcf2e.js"><link rel="prefetch" href="/assets/js/82.9888647c.js"><link rel="prefetch" href="/assets/js/83.d34e3c2a.js"><link rel="prefetch" href="/assets/js/84.0ba58301.js"><link rel="prefetch" href="/assets/js/85.5eb92f6d.js"><link rel="prefetch" href="/assets/js/86.efb3c6d4.js"><link rel="prefetch" href="/assets/js/87.c94d3f79.js"><link rel="prefetch" href="/assets/js/88.62d6286c.js"><link rel="prefetch" href="/assets/js/89.20284e25.js"><link rel="prefetch" href="/assets/js/90.af28317f.js"><link rel="prefetch" href="/assets/js/91.2909df0b.js"><link rel="prefetch" href="/assets/js/92.f47bc2a3.js"><link rel="prefetch" href="/assets/js/93.87f9b7c1.js"><link rel="prefetch" href="/assets/js/94.73eab5f3.js"><link rel="prefetch" href="/assets/js/95.5f08aca2.js"><link rel="prefetch" href="/assets/js/96.a82b607f.js"><link rel="prefetch" href="/assets/js/97.c61bfb76.js"><link rel="prefetch" href="/assets/js/98.55e7d7db.js"><link rel="prefetch" href="/assets/js/99.f1ab16a4.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.3b28fe31.js">
    <link rel="stylesheet" href="/assets/css/0.styles.dd3f1dd5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="lin" class="logo"> <span class="site-name can-hide">lin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/知识碎片/" class="nav-link"><!---->
  知识碎片
</a></div><div class="nav-item"><a href="/读书笔记/" class="nav-link"><!---->
  读书笔记
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/知识碎片/" class="nav-link"><!---->
  知识碎片
</a></div><div class="nav-item"><a href="/读书笔记/" class="nav-link"><!---->
  读书笔记
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="content"><div style="width:100%"><div class="theme-default-content custom-content content__default"><h1 id="java基础"><a href="#java基础" class="header-anchor">#</a> Java基础</h1> <h1 id="_1-自我介绍"><a href="#_1-自我介绍" class="header-anchor">#</a> 1.自我介绍</h1> <p>面试官你好，我叫曹梦，今年25岁，之前在郑州做了一年开发，做过两个项目。主要的技术栈是springboot，mybatisplus,mysql,redis。也了解一些前端的技术，比如js，css，vue，小程序这些，会使用一些linux命令，docker</p> <h1 id="_2-什么是面向对象"><a href="#_2-什么是面向对象" class="header-anchor">#</a> 2.什么是面向对象</h1> <ul><li><p>老师笔记</p> <p>面向过程：拆解成每个步骤，一步一步来</p> <p>面向对象：将洗衣拆成人和洗衣机，然后通过调用人.方法和洗衣机.方法 完成洗衣的动作。</p> <p>面向过程更加注重步骤和顺序，它的性能比较强</p> <p>面向对象，更加易于复用，更加易于拓展</p> <p>面向对向的时候，必须要说封装继承多态</p> <p>封装：内部细节对外部调用者不透明，拿来直接用，你不用管怎么实现。黑箱</p> <p>继承：继承基类的方法，并对其进行改编。将共性的东西，抽离出来放到父类当中，这样可以达到代码复用</p> <p>多态：多态有一个前提，就是要有继承，有方法重写，父类引用指向子类对象。</p></li></ul> <h1 id="_3-jdk-jre-jvm三者的联系和区别"><a href="#_3-jdk-jre-jvm三者的联系和区别" class="header-anchor">#</a> 3.JDK，JRE，JVM三者的联系和区别</h1> <ul><li><p>老师笔记</p> <p>jdk: java development kit 开发工具</p> <p>jre: java runtime environment java运行环境</p> <p>如果我们只是普通用户，我们只需要下载java运行环境就可以了。</p> <p>包括bin文件，jvm的文件夹 和 lib文件，放类库的文件夹</p> <p>jvm:java virtual machine</p> <p>由jdk中的java工具javac编译成class文件。将.class文件放到jvm中</p> <p>将class文件解释成为不同机器适配的机器码，从而实现一次开发，多种设备之间都可以运行</p></li></ul> <h1 id="_4-和equals"><a href="#_4-和equals" class="header-anchor">#</a> 4.==和equals</h1> <ul><li><p>老师笔记</p> <p>equals 如果不重写其实和==是一样的</p> <p>== 是比较栈中存放的值，基本数据类型是变量值，引用类型的话比较引用的地址。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>string a <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span>
string b <span class="token operator">=</span> <span class="token keyword">new</span> string <span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span>
<span class="token comment">//a 中的&quot;hello world&quot; 会放入堆中常量池</span>
<span class="token comment">//b中的内容会放在堆中非常量池</span>
<span class="token comment">//a 只是引用地址，放在栈中</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul> <h1 id="_5-谈谈你对-约定优于配置-的理解"><a href="#_5-谈谈你对-约定优于配置-的理解" class="header-anchor">#</a> 5.谈谈你对”约定优于配置”的理解</h1> <ul><li><p>自己总结</p> <p>“约定优于配置”是一种软件设计范式，它指的是遵循一种约定俗称的范式去进行开发，这种开发模式降低了开发人员的工作量，增强了代码的可读性，又不失一定的灵活性。</p> <p>许多框架都有约定优于配置的理念在其中，比如maven</p></li></ul> <h1 id="_6-简述final的作用"><a href="#_6-简述final的作用" class="header-anchor">#</a> 6.简述final的作用；</h1> <ul><li><p>总结</p> <p>final可以修饰类，变量，方法</p> <p>修饰类表示这个类是太监类，不能被继承，也不能够被实现，所以接口不能够被使用。</p> <p>修饰变量，表示一旦变量被赋值，就没办法再修改值。修饰基本数据类型，一旦final之后就无法更改，修饰引用数据类型，引用的地址不能改变，但是它的值可以改变。</p> <p>修饰方法，不能够被重写，但是可以被重载</p></li></ul> <h1 id="_7-为什么局部内部类和匿名内部类只能访问局部final的变量"><a href="#_7-为什么局部内部类和匿名内部类只能访问局部final的变量" class="header-anchor">#</a> 7.为什么局部内部类和匿名内部类只能访问局部final的变量</h1> <ul><li><p>总结</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul> <p>使用匿名内部类和局部内部类编译出来的字节码文件有两个，一个是主体的字节码文件，另外一个就是内部类。当主体字节码文件执行被垃圾回收之后，内部类没有办法获得类变量，所以它在之前就会cope一份类变量给自己，但是类变量有可能会变，所以使用final修饰类变量。</p> <h1 id="_8-string-stringbuilder-stringbuffer"><a href="#_8-string-stringbuilder-stringbuffer" class="header-anchor">#</a> 8.String,StringBuilder,StringBuffer</h1> <ul><li><p>总结</p> <p>String 的每一次修改都会new一个新对象，如果这个变量修改比较频繁的话，那么就会比较浪费空间。</p> <p>stringbuilder是线程不安全的</p> <p>stringbuffer它的方法都被<code>synchronized</code></p> <p>速度</p> <p>stringbuilder&gt;stringbuffer&gt;string</p> <p>经常改变字符的我们用stringbuffer和stringbuiler</p> <p>优先使用stringbuiler，多线程的时候使用stringbuffer</p></li></ul> <h1 id="_9-泛型中extends和super的区别"><a href="#_9-泛型中extends和super的区别" class="header-anchor">#</a> 9.泛型中extends和super的区别</h1> <ol><li>
&lt;?extends T&gt;表示包含T在内的任何T的子类
</li> <li>
&lt;? super T&gt;表示包括T在内任何T的父类 
</li></ol> <p>我们使用getClass没有办法获取方法的泛型，泛型擦除。</p> <h1 id="_10-重载、重写的区别"><a href="#_10-重载、重写的区别" class="header-anchor">#</a> 10.重载、重写的区别</h1> <ul><li><p>总结</p> <p>重载：</p> <p>发生在同一个类当中，方法名相同，参数类型，数量必须不同。</p> <p>重写</p> <p>发生在子类中，子类继承父类，重写方法，方法名必须相同，参数列表必须相同，返回值和抛出异常小于等于父类，访问修饰符大于等于父类，privite修饰的不能被重写。</p></li></ul> <h1 id="_11-接口和抽象类的区别"><a href="#_11-接口和抽象类的区别" class="header-anchor">#</a> 11.接口和抽象类的区别</h1> <ul><li><p>总结</p> <p>接口设计的目的是为了方法的有无</p> <p>抽象类设计的目的是为了实现接口的复用</p></li></ul> <h1 id="_12-list和set的区别"><a href="#_12-list和set的区别" class="header-anchor">#</a> 12.List和Set的区别</h1> <ul><li>总结
<ul><li><p>List</p> <p>有序列表，按照对象进入的顺序储存对象，可以重复，可以有多个null存，可以使用iteretor逐一存，使用get取。使用interater遍历</p></li> <li><p>Set</p> <p>无序列表，不可重复，最多有一个null存，使用interater遍历</p></li></ul></li></ul> <h1 id="_13-arraylist和linkedlist区别"><a href="#_13-arraylist和linkedlist区别" class="header-anchor">#</a> 13.ArrayList和LinkedList区别</h1> <ul><li>笔记
<ul><li>首先，他们的底层数据结构是不一样的，ArryList是数组，LinkList就是基于链表实现的。数组更加适合查找，链表更加适合添加删除。</li> <li>由于底层数据结构不同，他们适用的场景也就不同，ArryList更加适合随机查找，LinkList更加适合删除和添加，查询、添加、删除的时间复杂度不同。</li> <li>另外ArryList和LinkList实现List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当成队列使用</li></ul></li></ul> <h1 id="_14-hashcode和equals区别"><a href="#_14-hashcode和equals区别" class="header-anchor">#</a> 14.hashCode和equals区别</h1> <ul><li><p>笔记</p> <p>hashCode源自于object类，所有的类都默认继承这个类，所以所有的类都可以使用这个方法。</p> <p>hashCode方法指向实例化对象在堆中的hash地址，可以用这个方法来看你实例化后的对象是不是一个对象。比如我们创建string对象，我们使用hashcode方法来打印他的地址，然后修改对象，再用hashcode打印，发现他们两个打印的地址是不一样的。new stringbuilder或者string buffer，发现他们打印的是一样的。</p> <p>equals如果不重写的话，它和==是一样的，都是比较对象的地址，如果重写的话，一般都会比较对象的值。</p></li></ul> <h1 id="_15-hashmap和hashtable的区别和底层实现"><a href="#_15-hashmap和hashtable的区别和底层实现" class="header-anchor">#</a> 15.HashMap和HashTable的区别和底层实现</h1> <p>HashMap和HashTable他们实现的接口和继承的方法都一样，但是HashTable的返回值使用Sycronized修饰，说明它是线程安全的，HashMap线程是不安全的。HashMap在多线程情况下，有可能执行结果会出现不一样，HashTable则不会有这个问题。</p> <p>HashMap允许key和value为null，而HashTable则不允许</p> <p>底层实现：数组加链表实现</p> <h1 id="_16-如何实现一个ioc容器"><a href="#_16-如何实现一个ioc容器" class="header-anchor">#</a> 16.如何实现一个IOC容器</h1> <ol><li>配置文件，配置包扫描路径</li> <li>递归包扫描  .class文件</li> <li>反射，确定需要较为ioc管理的类</li> <li>对需要注入的类进行依赖注入</li></ol> <ul><li>配置文件中需要扫描的路径</li> <li>定义一些注解，业务服务层，数据持久层，依赖注入层，获取配置文件注解</li> <li>从配置文件中获取要扫描的包路径，获取到当前文件信息及文件夹信息，将所有这些包下面的.class文件都放到set集合中存。</li> <li>便利这个集合，获取这些集合上面有指定注释的类，把它交给ioc容器，定义一个安全的map来存这些对象</li> <li>遍历整个ioc容器，获取每一个类上面的实例，判断里面有没有依赖其它类的实例，然后进行递归注入。</li></ul> <h1 id="_17-什么是字节码-采用字节码的好处是什么。"><a href="#_17-什么是字节码-采用字节码的好处是什么。" class="header-anchor">#</a> 17.什么是字节码？采用字节码的好处是什么。</h1> <ul><li><p>总结</p> <p><a href="http://xn--ide-db9dr2ahzy1i27fe81bba0874c5caq78m.java" target="_blank" rel="noopener noreferrer">我们使用ide编写之后生成.java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件要经过javac编译，编译之后的文件就是字节码。</p> <p>由jvm 通过解释器将.class文件解释为特定系统的机器码，</p> <p>采用字节码的好处是，一次编译，处处运行。</p> <p>java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可以移植的特点。所以java语言运行起来比较高效，而且由于字节码并不转对于某一种特定的机器，所以java无需重新编译便可在多种不同的计算机上运行。</p></li></ul> <h1 id="_18-java类加载器有哪些"><a href="#_18-java类加载器有哪些" class="header-anchor">#</a> 18.java类加载器有哪些</h1> <ul><li><p>总结</p> <p>JDK自带的三个类加载器：boostrap ClassLoad（顶层的类加载器），ExtClassLoader,AppClassLoad</p> <p>boostrap ClassLoad是ExtClassLoader的父加载器，默认负载加载%java_home%lib下的jar包和class文件</p> <p>ExtClassLoader是AppClassLoad父类加载器，负责加载%java_home%lib/ext文件夹下的jar包和class类，AppClassLoad是自定义加载器的父类，负载加载classpath下的类文件。系统类加载器，线程上下文加载器。</p></li></ul> <h1 id="_19-双亲委派模型"><a href="#_19-双亲委派模型" class="header-anchor">#</a> 19.双亲委派模型</h1> <ul><li><p>总结</p> <p>parents delegate 父委托，上溯委托</p> <p><img alt="Untitled" data-src="Java%E5%9F%BA%E7%A1%80%20672320c7a2234ca1bac271e681f17e31/Untitled.png" loading="lazy" class="lazy"></p> <p>先说几个类加载器</p> <p>向上委派就是查找类加载缓存，如果缓存中有，就返回。向下查找就是查找类加载路径。向上委派委派到bootstarpClassLoad,向下查找查找到自定义类加载器。</p> <p>好处：</p> <p>安全性：</p> <p>自己写的类和jdk冲突的时候，不会加载你自己写的类。</p> <p>不仅仅是根据你写的类的全路径，还会根据哪个类加载器</p></li></ul> <h1 id="_20-java中的异常体系"><a href="#_20-java中的异常体系" class="header-anchor">#</a> 20.java中的异常体系</h1> <ul><li><p>总结</p> <p>Java中所有的异常都来自Throwable</p> <p>Throwable下有两个子类exception（能够处理和干预的）和error（程序无法处理 OOM（内存溢出））</p> <p>Excepton不会导致程序终止（nullException），分为RuntimeException（运行时异常）和CheckedException检查异常，编译时就会发现。</p></li></ul> <h1 id="_21-gc如何判断对象可以被回收"><a href="#_21-gc如何判断对象可以被回收" class="header-anchor">#</a> 21.GC如何判断对象可以被回收</h1> <ul><li><p>引用计数法</p> <p>每一个对象都有一个引用计数器，新增一个引用时计数器+1，引用释放时计数-1，计数为0的时候可以回收。</p> <p>引用计数法容易产生循环引用，会导致相互引用的的方法永远不能被回收。</p></li> <li><p>可达性分析法：（java使用）</p> <p>从GCRoot开始向下搜索，当一个对象到GCRoot没有任何引用链相连的时候，那么这个对象和与之相关联的对象就可以被GC回收。</p> <p>GCRoot的对象有：</p> <ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li> <li>方法区中类静态属性引用的对象。</li> <li>方法区中常量引用的对象</li> <li>本地方法栈中中的JNI（一般说的Native方法）引用的对象</li></ul> <p>可达性算法中的不可达对象不是立即死亡的，对象被系统宣告死亡至少要经历两次标记过程：第一次分析时经过可达性分析发现没有与GCRoot相连接的引用链，第二次是由虚拟机自动简历的finalizer队列中判断是否需要执行</p> <p>finalize（）方法。</p></li></ul> <h1 id="_22-线程的生命周期和线程的状态"><a href="#_22-线程的生命周期和线程的状态" class="header-anchor">#</a> 22.线程的生命周期和线程的状态</h1> <ul><li><p>总结</p> <p>线程有五种状态，创建，就绪，运行，阻塞和死亡</p> <p>阻塞分为三种：</p> <ol><li><p>等待阻塞：运行的线程执行wait（）方法，该线程会释放占用的所有的资源，包括锁资源。jvm会把线程放到等待池之中，进入这个状态之后，是不能被唤醒的，必须依靠其它线程调用notify或者notifyAll（）方法才能被唤醒，wait时objece类的方法。</p></li> <li><p>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</p></li> <li><p>其它阻塞：运行的线程执行sleep或join（）方法，或者发出了I/O请求，jvm会把该线程设置为阻塞状态。当sleep状态超时、join等待线程结束或者超时、或者I/O处理完毕时，线程重新转入就绪状态，sleep时Thread类方法</p></li> <li><p>新建状态（New）：新建一个线程对象。</p></li> <li><p>就绪状态（Runable）：线程对象创建好后</p></li></ol></li></ul> <h1 id="_23-说一下hashmap的put方法"><a href="#_23-说一下hashmap的put方法" class="header-anchor">#</a> 23.说一下HashMap的Put方法</h1> <ul><li><p>总结</p> <p>先说hashmap的put方法的具体流程</p> <ol><li>拿到key，根据hash算法的与运算拿到数组下标</li> <li>如果当前数组下标为空，那么将这个key和value封装成entry对象（1.7为entry对象，1.8为node对象）并放到该位置。</li> <li>如果数组下标位置不为空
<ol><li>如果是jdk1.7的话，它会先判断要不要扩容，如果要扩容，它就扩容，如果它不要扩容，那么就不用扩容，生成entry对象通过头插法插入到当前链表中。</li> <li>如果为红黑树node，如果这个红黑树上面没有要添加的node，那么就把这个node添加到红黑树当中，如果有有当前的key，那么就更新value。</li> <li>如果是jdk1.8的话，会先去判断node类型，是红黑树node还是链表node。
<ol><li>如果当前node是链表node的话，通过尾插法将node添加到链表尾部，在添加的过程中，将会遍历整个链表，如果这个时候链表中有key，那么更新value,在更新完之后，如果整个链表的长度大于等于8的话，整个链表转为红黑树</li> <li>将node插入到链表或者红黑树之后，判断是否需要扩容，如果要扩容，就对其进行扩容，如果不需要就结束put方法。</li></ol></li></ol></li></ol></li></ul> <h1 id="_24-jdk1-7到jdk1-8-hashmap发生了什么变化-底层"><a href="#_24-jdk1-7到jdk1-8-hashmap发生了什么变化-底层" class="header-anchor">#</a> 24.jdk1.7到jdk1.8 HashMap发生了什么变化（底层）？</h1> <ul><li>总结
<ol><li>1.7中底层时数组+链表。1.8底层时数组+链表+红黑树，加红黑树的目的是为了提高hashmap插入和查询的效率。</li> <li>1.7中链表插入使用的是头插法，1.8中链表使用的是尾插法。</li> <li>1.7中哈希算法比较复杂，使用了很多的右移与互运算，1.8中进行了简化，因为复杂的哈希算法的目的是提高了散列性，提高hashmap的整体效率，而1.8中新增了红黑树，所以可以适当降低哈希算法的复杂性，提高程序的整体运行效率。</li></ol></li></ul> <h1 id="_25-谈谈concurrenthashmap的扩容机制"><a href="#_25-谈谈concurrenthashmap的扩容机制" class="header-anchor">#</a> 25.谈谈ConcurrentHashMap的扩容机制</h1> <ul><li><p>总结</p> <p>1.8版本</p> <ol><li>扩容之前先对要扩容的数组进行分组，然后通过不同线程来进行转移，每个线程负责一块的工作。</li> <li>扩容之前先生成一个新数组</li> <li>1.8版本的concurrentHashMap不再基于segment实现</li> <li>当某个线程put时发现concurrentHashMap正在扩容的时候，它会帮忙过来一起扩容。</li> <li>如果某个线程put时没有发现concurrentHanshmap在扩容，则将key-value添加到concurrentHashmap，然后判断concurrentHashmap要不要扩容，如果要的话，就对它进行扩容。</li> <li>concurrentHashMap支持多个线程一起扩容</li></ol> <p>1.7版本</p> <ol><li>基于segment分段来实现</li> <li>每个segment相当于一个小型的hashmap</li> <li>每个segmet内部都会扩容，和hashmap扩容逻辑形似</li> <li>先生成新的数组，然后转移数组到新的数组当中</li> <li>扩容的判断也是每个segment内部判断的，判断是否超过阈值</li></ol></li></ul> <h1 id="_26-深拷贝和浅拷贝"><a href="#_26-深拷贝和浅拷贝" class="header-anchor">#</a> 26.深拷贝和浅拷贝</h1> <ul><li>总结
<ul><li>浅拷贝 浅拷贝拷贝基本数据类型的值，还有引用数据类型的地址。</li> <li>深拷贝 深拷贝拷贝基本数据类型的值，引用数据类型的所有。</li></ul></li></ul> <h1 id="_27-hashmap的扩容机制原理"><a href="#_27-hashmap的扩容机制原理" class="header-anchor">#</a> 27.HashMap的扩容机制原理</h1> <ul><li><p>总结</p> <p>1.7版本</p> <ol><li>先生成新数组</li> <li>遍历老数组中的每个位置上的链表上的每一个元素</li> <li>去每一个元素的key，并基于新数组的长度，给每一个元素计算下标</li> <li>将元素添加到新数组上去</li> <li>所有元素转移完之后，将新数组赋值给hashmap中的table属性</li></ol> <p>1.8版本</p> <ol><li>先生成新数组</li> <li>遍历老数组中的链表或者红黑树</li> <li>如果是链表，将链表中元素的下标通过hash运算添加到新数组中</li> <li>如果是红黑树，计算红黑树中每个元素在新数组的下标
<ol><li>统计每个下标位置的元素数</li> <li>如果元素数超过了8，则生成一个新的红黑树，并且将根节点添加到新数组的对应位置。</li> <li>如果没有超过8，则生成一个链表，将链表的头节点添加到新数组的对应位置。</li></ol></li> <li>所有元素转移完之后，将新数组赋值给hashmap中的table属性</li></ol></li></ul> <h1 id="_28-什么时候抛出异常-什么时候捕获异常"><a href="#_28-什么时候抛出异常-什么时候捕获异常" class="header-anchor">#</a> 28.什么时候抛出异常，什么时候捕获异常</h1> <ul><li><p>总结</p> <p>能够处理就处理，不能够处理就抛出去。</p></li></ul> <h1 id="_29-说说对线程安全的理解"><a href="#_29-说说对线程安全的理解" class="header-anchor">#</a> 29.说说对线程安全的理解</h1> <ul><li><p>总结</p> <p>线程安全的意思就是，多个线程执行一段程序，结果不会出现混乱。比如i=0，两个线程同时执行i++，正常情况下，一个结果时1，另外一个结果时2，这个时候我们可以说这这段代码时线程安全的。如果两个线程的结果都为1，则表示这段代码是线程不安全的。</p> <p>线程安全指的是同一段代码被同时执行，能否得到正确的结果。</p></li></ul> <h1 id="说说对守护线程的理解"><a href="#说说对守护线程的理解" class="header-anchor">#</a> 说说对守护线程的理解</h1> <ul><li><p>总结</p> <p>线程分为守护线程和用户线程，用户线程就是普通线程，守护线程就是jvm的后台线程，守护线程会在其它普通线程都关闭之后自动关闭，我们可以通过thread.setdaemon（）来把普通线程设置为守护线程。</p></li></ul> <h1 id="threadlocal的底层原理"><a href="#threadlocal的底层原理" class="header-anchor">#</a> ThreadLocal的底层原理</h1> <ul><li>总结
<ol><li>ThreadLocal是java提供的线程本地储存技术，可以利用该机制将数据缓存到线程内部，该线程可以在任意时刻，任意位置获取缓存的数据。</li> <li>ThreadLocal通过ThreadLocalMap实现，每一个Thread对象（不是Thread对象）都存在一个ThreadLocalMap，Map的key是ThreadLoacl对象，map的值是缓存的值。</li> <li>如果使用完ThreadLocal之后，一定要把ThreadLocal的值回收，如果不回收，有可能导致内存泄漏，解决的办法就是获取完ThreadLocal对象之后，进行remove</li></ol></li></ul> <h1 id="并发、并行、串行之间的区别"><a href="#并发、并行、串行之间的区别" class="header-anchor">#</a> 并发、并行、串行之间的区别</h1> <ul><li><p>总结</p> <p>并发：</p> <p>程序在一个系统中运行，每一个时刻只有一个线程在使用</p> <p>并行：</p> <p>程序在一个系统中运行，所有线程一起执行</p> <p>串行：</p> <p>程序在一个系统中运行，按照顺序执行，前面没有执行完，后面不能执行</p></li></ul></div> <div class="page-meta"><footer class="page-edit" style="margin:0;"><!----> <!----></footer> <div class="page-views" data-v-1a66a508><i class="fas fa-eye" data-v-1a66a508></i> <span class="view-count" data-v-1a66a508><span id="busuanzi_container_page_pv" style="display: none;" data-v-1a66a508>
            阅读次数: <span id="busuanzi_value_page_pv" data-v-1a66a508>0</span></span></span></div></div> <!----></div> <div class="toc-container-sidebar"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="max-height:86vh"><div style="font-weight:bold;">Java基础</div> <hr> <div class="toc-box"><!----></div></div></div></div></div>  <main class="footer"> <div class="copy-right"><a target="_blank" rel="noreferrer">
              
            </a></div></main></main> <aside class="page-sidebar"> <div class="page-side-toolbar"></div>  </aside></div><div class="global-ui"><div></div><!----></div></div>
    <script src="/assets/js/app.ca6810f0.js" defer></script><script src="/assets/js/1.a7899151.js" defer></script><script src="/assets/js/67.dc48310c.js" defer></script>
  </body>
</html>
