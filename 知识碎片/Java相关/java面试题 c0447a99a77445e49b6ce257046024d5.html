<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>java面试题 | lin</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <meta name="description" content="记录进步的点滴">
    <meta property="og:site_name" content="lin">
    <meta property="og:title" content="java面试题">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://bigdragonlin.github.io/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html">
    <meta name="twitter:title" content="java面试题">
    <meta name="twitter:url" content="https://bigdragonlin.github.io/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="程序员, 编程, 计算机">
    <meta property="article:tag" content="程序员">
    <meta name="keywords" content="编程学习路线, 编程知识百科, Java, 编程导航, 前端, 开发, 编程分享, 项目, IT, 求职, 面经">
    
    <link rel="preload" href="/assets/css/0.styles.dd3f1dd5.css" as="style"><link rel="preload" href="/assets/js/app.ca6810f0.js" as="script"><link rel="preload" href="/assets/js/1.a7899151.js" as="script"><link rel="preload" href="/assets/js/76.aaca7275.js" as="script"><link rel="prefetch" href="/assets/js/10.8111f976.js"><link rel="prefetch" href="/assets/js/100.c3d9648c.js"><link rel="prefetch" href="/assets/js/101.31bd77ed.js"><link rel="prefetch" href="/assets/js/102.75748718.js"><link rel="prefetch" href="/assets/js/103.fefc26c8.js"><link rel="prefetch" href="/assets/js/104.6833bd21.js"><link rel="prefetch" href="/assets/js/105.2a44ef65.js"><link rel="prefetch" href="/assets/js/106.b085d75e.js"><link rel="prefetch" href="/assets/js/107.d43eadfd.js"><link rel="prefetch" href="/assets/js/108.a82c88db.js"><link rel="prefetch" href="/assets/js/109.43567b2e.js"><link rel="prefetch" href="/assets/js/11.675ae2e2.js"><link rel="prefetch" href="/assets/js/110.e9b76f2e.js"><link rel="prefetch" href="/assets/js/111.228eb17e.js"><link rel="prefetch" href="/assets/js/112.16977eac.js"><link rel="prefetch" href="/assets/js/113.bf85006c.js"><link rel="prefetch" href="/assets/js/114.1feafc0d.js"><link rel="prefetch" href="/assets/js/115.27c63cfd.js"><link rel="prefetch" href="/assets/js/116.6b258b63.js"><link rel="prefetch" href="/assets/js/117.2a4ea694.js"><link rel="prefetch" href="/assets/js/118.14319035.js"><link rel="prefetch" href="/assets/js/119.b45026b0.js"><link rel="prefetch" href="/assets/js/12.611fe139.js"><link rel="prefetch" href="/assets/js/120.f3eada75.js"><link rel="prefetch" href="/assets/js/121.d5813ad6.js"><link rel="prefetch" href="/assets/js/122.203b5e6a.js"><link rel="prefetch" href="/assets/js/123.8c4f7397.js"><link rel="prefetch" href="/assets/js/124.04cff09e.js"><link rel="prefetch" href="/assets/js/125.05b77e9b.js"><link rel="prefetch" href="/assets/js/126.385ad5db.js"><link rel="prefetch" href="/assets/js/127.5c05acb6.js"><link rel="prefetch" href="/assets/js/128.acc58546.js"><link rel="prefetch" href="/assets/js/129.e9e12ec9.js"><link rel="prefetch" href="/assets/js/13.bbcb9761.js"><link rel="prefetch" href="/assets/js/130.eb6bd4fc.js"><link rel="prefetch" href="/assets/js/131.77bc5ddd.js"><link rel="prefetch" href="/assets/js/132.a696f9a5.js"><link rel="prefetch" href="/assets/js/133.bd92160a.js"><link rel="prefetch" href="/assets/js/134.92264011.js"><link rel="prefetch" href="/assets/js/135.9a1d9b8a.js"><link rel="prefetch" href="/assets/js/136.e3f55bc9.js"><link rel="prefetch" href="/assets/js/137.38a53ca5.js"><link rel="prefetch" href="/assets/js/138.9af220ba.js"><link rel="prefetch" href="/assets/js/139.2ea1d0aa.js"><link rel="prefetch" href="/assets/js/14.27da1495.js"><link rel="prefetch" href="/assets/js/140.f24895fe.js"><link rel="prefetch" href="/assets/js/141.8380d4d5.js"><link rel="prefetch" href="/assets/js/142.cef7432d.js"><link rel="prefetch" href="/assets/js/143.7a359979.js"><link rel="prefetch" href="/assets/js/144.d135462b.js"><link rel="prefetch" href="/assets/js/145.b6f69890.js"><link rel="prefetch" href="/assets/js/146.66faecd7.js"><link rel="prefetch" href="/assets/js/15.49e75645.js"><link rel="prefetch" href="/assets/js/16.09145204.js"><link rel="prefetch" href="/assets/js/17.6b86b1e5.js"><link rel="prefetch" href="/assets/js/18.d042910d.js"><link rel="prefetch" href="/assets/js/19.ddb3a096.js"><link rel="prefetch" href="/assets/js/2.d74f4bad.js"><link rel="prefetch" href="/assets/js/20.3ace0aa5.js"><link rel="prefetch" href="/assets/js/21.7eb1c3cc.js"><link rel="prefetch" href="/assets/js/22.cff4c035.js"><link rel="prefetch" href="/assets/js/23.07adb667.js"><link rel="prefetch" href="/assets/js/24.29d6a672.js"><link rel="prefetch" href="/assets/js/25.f83be928.js"><link rel="prefetch" href="/assets/js/26.d1712bb0.js"><link rel="prefetch" href="/assets/js/27.25530b6e.js"><link rel="prefetch" href="/assets/js/28.a340957f.js"><link rel="prefetch" href="/assets/js/29.f2754eb7.js"><link rel="prefetch" href="/assets/js/3.72a02e88.js"><link rel="prefetch" href="/assets/js/30.9ac4febe.js"><link rel="prefetch" href="/assets/js/31.1dde25cc.js"><link rel="prefetch" href="/assets/js/32.4087c135.js"><link rel="prefetch" href="/assets/js/33.7696f9d2.js"><link rel="prefetch" href="/assets/js/34.56b8aa20.js"><link rel="prefetch" href="/assets/js/35.e5dd505a.js"><link rel="prefetch" href="/assets/js/36.0906ffc8.js"><link rel="prefetch" href="/assets/js/37.4bf277b3.js"><link rel="prefetch" href="/assets/js/38.898c86e2.js"><link rel="prefetch" href="/assets/js/39.2b08ff32.js"><link rel="prefetch" href="/assets/js/4.2002c685.js"><link rel="prefetch" href="/assets/js/40.de5b4385.js"><link rel="prefetch" href="/assets/js/41.4b058022.js"><link rel="prefetch" href="/assets/js/42.d9754d64.js"><link rel="prefetch" href="/assets/js/43.3d8af8e3.js"><link rel="prefetch" href="/assets/js/44.b49601c7.js"><link rel="prefetch" href="/assets/js/45.3fb7a5e7.js"><link rel="prefetch" href="/assets/js/46.7512c87a.js"><link rel="prefetch" href="/assets/js/47.69f52a8d.js"><link rel="prefetch" href="/assets/js/48.48367446.js"><link rel="prefetch" href="/assets/js/49.154237f1.js"><link rel="prefetch" href="/assets/js/5.ed8fd711.js"><link rel="prefetch" href="/assets/js/50.2d51489f.js"><link rel="prefetch" href="/assets/js/51.e3e48a00.js"><link rel="prefetch" href="/assets/js/52.71319e9d.js"><link rel="prefetch" href="/assets/js/53.76670559.js"><link rel="prefetch" href="/assets/js/54.b2a18c59.js"><link rel="prefetch" href="/assets/js/55.a206441f.js"><link rel="prefetch" href="/assets/js/56.602248d0.js"><link rel="prefetch" href="/assets/js/57.163afc2d.js"><link rel="prefetch" href="/assets/js/58.a2057559.js"><link rel="prefetch" href="/assets/js/59.3c0e4c86.js"><link rel="prefetch" href="/assets/js/6.a237149d.js"><link rel="prefetch" href="/assets/js/60.9d8d9dbc.js"><link rel="prefetch" href="/assets/js/61.b3811e77.js"><link rel="prefetch" href="/assets/js/62.5d38f7cd.js"><link rel="prefetch" href="/assets/js/63.264e91fb.js"><link rel="prefetch" href="/assets/js/64.4b55aee3.js"><link rel="prefetch" href="/assets/js/65.09c20b34.js"><link rel="prefetch" href="/assets/js/66.0fc1c46a.js"><link rel="prefetch" href="/assets/js/67.dc48310c.js"><link rel="prefetch" href="/assets/js/68.5d8c23b0.js"><link rel="prefetch" href="/assets/js/69.03cbc1c9.js"><link rel="prefetch" href="/assets/js/7.b3d59ec2.js"><link rel="prefetch" href="/assets/js/70.b2a017c1.js"><link rel="prefetch" href="/assets/js/71.da6e8dd0.js"><link rel="prefetch" href="/assets/js/72.679cfcfc.js"><link rel="prefetch" href="/assets/js/73.302bc7b7.js"><link rel="prefetch" href="/assets/js/74.f47f2a86.js"><link rel="prefetch" href="/assets/js/75.0435670f.js"><link rel="prefetch" href="/assets/js/77.1b271da3.js"><link rel="prefetch" href="/assets/js/78.476a924e.js"><link rel="prefetch" href="/assets/js/79.23be6cff.js"><link rel="prefetch" href="/assets/js/80.d592bdd2.js"><link rel="prefetch" href="/assets/js/81.461bcf2e.js"><link rel="prefetch" href="/assets/js/82.9888647c.js"><link rel="prefetch" href="/assets/js/83.d34e3c2a.js"><link rel="prefetch" href="/assets/js/84.0ba58301.js"><link rel="prefetch" href="/assets/js/85.5eb92f6d.js"><link rel="prefetch" href="/assets/js/86.efb3c6d4.js"><link rel="prefetch" href="/assets/js/87.c94d3f79.js"><link rel="prefetch" href="/assets/js/88.62d6286c.js"><link rel="prefetch" href="/assets/js/89.20284e25.js"><link rel="prefetch" href="/assets/js/90.af28317f.js"><link rel="prefetch" href="/assets/js/91.2909df0b.js"><link rel="prefetch" href="/assets/js/92.f47bc2a3.js"><link rel="prefetch" href="/assets/js/93.87f9b7c1.js"><link rel="prefetch" href="/assets/js/94.73eab5f3.js"><link rel="prefetch" href="/assets/js/95.5f08aca2.js"><link rel="prefetch" href="/assets/js/96.a82b607f.js"><link rel="prefetch" href="/assets/js/97.c61bfb76.js"><link rel="prefetch" href="/assets/js/98.55e7d7db.js"><link rel="prefetch" href="/assets/js/99.f1ab16a4.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.3b28fe31.js">
    <link rel="stylesheet" href="/assets/css/0.styles.dd3f1dd5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="lin" class="logo"> <span class="site-name can-hide">lin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/知识碎片/" class="nav-link"><!---->
  知识碎片
</a></div><div class="nav-item"><a href="/读书笔记/" class="nav-link"><!---->
  读书笔记
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/知识碎片/" class="nav-link"><!---->
  知识碎片
</a></div><div class="nav-item"><a href="/读书笔记/" class="nav-link"><!---->
  读书笔记
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="content"><div style="width:100%"><div class="theme-default-content custom-content content__default"><h1 id="java面试题"><a href="#java面试题" class="header-anchor">#</a> java面试题</h1> <p><a href="https://docs.google.com/document/d/1utoRr1fV6jOIyFGhohNrf26rBC36hXy4qZblkN_k4lM/edit?usp=drivesdk" target="_blank" rel="noopener noreferrer">Java软件工程师面试-超级经典面试题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="javase"><a href="#javase" class="header-anchor">#</a> JavaSE</h1> <h3 id="string"><a href="#string" class="header-anchor">#</a> String：</h3> <p>1，常用API</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>toString()subString()chaArr()replace()split()getbytes()contains()equals()trim()
charAt()length()comparTo()

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>2，String的特性？实现原理？</p> <p>3，什么是字符串常量池？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>字符串的分配，与其他对象分配相同，耗费时间和空间。jvm为了提高性能和内存开销，在实例化字符串常量池的时候进行了优化，为了减少jvm创建字符串的数量，所以维护了一个字符串常量池，每当创建字符串时首先到字符串常查找是否存在这个字符串，存在则返回实例引用，否则就实例化并放入常量池中。
	这样的优化时基于String类型的不可变，不用担心数据冲突进行共享。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>4，String为什么不可变的？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>一个对象创建完毕后，不可以再次改变它的状态！（不可变性）
不能改变的意思是：不能改变对象内的成员变量，基本数据类型的值，引用数据类型不可以再次指向其他对象。
value，offest，count三个变量都是private，没有提供相应的set方法，所以外部无法访问这三个成员，而value，offset，count也是fianl修饰的所以一旦初始化就不可以改变！

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>5，String拼接字符串效率低的原因？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>String的+，以后会被编译为StringBuilder来运行，所以也就执行了new StringBuilder和toString的操作，所以new的对象并不会放入常量池，toString会发生一个内容拷贝，但是也不会在常量池中，所以在这里常量所以在这里（常量池String + 常量池String）放在了堆中。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>6，String的SubString真的会引起内存泄露么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>JDK1.6以前是会存在内存泄露问题
当是用subString（a,b）方法时，实际是调整了offset和count的指向，所以内容还是原来的字符串，并没有重新创建新的内容数组。
举例：比如有一个1g的字符串a，调用该字符串方法的subString（1，2）方法那么会的到两个字符的B。
如果此时手动将a指向修改为null，垃圾回收进行后，a被回收掉，但是b没有回收掉，所有内存占用依旧存在。因为B字符串持有a字符串的引用

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>7， String方法intern() 你真的会用吗？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>如果不是用双引号声明的String对象，可以使用String提供的intern（）方法，会从字符串常量中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。若存在当前字符串，就直接返回当前字符串，如果没有则先放入在返回。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="oop"><a href="#oop" class="header-anchor">#</a> OOP</h3> <p>1，什么是面向对象？什么是封装？什么是继承？什么是多态？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>面向对象：（对比讲）

继承：从已有的类中派生新的类，新的类有已有类的数据属性和行为但也可以以扩展新的能力。简单讲：就是儿子继承父亲的遗产，但是父亲私有的无法继承。儿子可以有自己的东西比如房子，钱，荣誉等。

多态：允许不同类的对象对同一消息做出响应，也就是同一个消息根据发送对象的不同采用不同的行为方式。比如：重写与重载都是方法名的多态体现，而父类引用指向子类对象也是多态的体现（前者实现运行时多态性，后者实现编译时的多态性）。多态主要是为了解耦合；

封装：隐藏对象的属性和实现细节，对外暴露公开接口，控制访问权限，用类实现封装，用封装来实现高内聚，低耦合。比如：JavaBean就是封装提供了getset方法，也就是说我们想要吃饭可以直接到饭店点菜吃饭，无需自己买菜洗菜炒菜上菜，所以我们只关系开始结束，不关心过程。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>2， Java中方法参数的传递规则？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>基本数据类型：值传递 （包括字符串）
引用数据类型：引用传递

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>3， Java中throw和throws的区别是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>throw：是创建并抛出一个具体的异常
throws：是声明这个方法可能会抛出异常信息，throws是将异常声明但并不处理，将异常交予调用者进行处理

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>4，重载和重写的区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>重载：一个类当中多个方法名相同但是参数不同，所以参数必须修改，返回值类型，异常，访问权限可改。重载会被overloading修饰
重写：子类对父类的方法进行重写。参数列表，返回值类型，不能修改。异常与访问只能更精确不可以更大。重写会被Overriding修饰

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>5，抽象类与接口的区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>抽象类：抽象类用来捕捉子类的通用特性，不可被实例化。抽象类使用abstract声明，可以有默认方法实现，使用extends关键字继承，可以有构造器，不可实例化，可以有main方法，比接口速度更快，可以有private，protected，default所修饰。

接口：是抽象方法的集合，类实现了某个接口那么就相当于继承了这个类中的抽象方法。1.7以后方法可以有方法体，使用implements来实现接口，不能有构造器，必须是public，1.8后可以有defalut和static方法。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>6，finally的坑，踩过吗？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>finally语句并不是每次都执行，只有线程执行过try语句块，finally语句才会被执行。如果线程执行到try语句块之前就return的话，finally语句是不会执行的。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>7， 为什么重写equals方法需同时重写hashCode方法？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>默认的重写equals方法是比较地址值，（String已经重写）重写以后比较的是值。
某个数据，通过算法得到hashCode值，然后将这个数据存入下标等于hashCode 的单元格里。这样，就将数据和数组下标关联起来了。因为hash碰撞，一个单元格可能存有多个数据， equals 就是为了比较一个单元格里是否有目标数据。就是你需要用到HashMap,HashSet等Java集合。用不到哈希表的话，其实仅仅重写equals()方法也可以吧。而工作中的场景是常常用到Java集合，所以Java官方建议 重写equals()就一定要重写hashCode()方法。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>8， equals() 与 == 的区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，对于基本数据类型，使用 == 比较值是否相等。
2，对于复合数据类型（类），使用equals和 == 效果一致，两者比较的都是内存中（堆）存放地址。
3，对于String，Integer，Date等覆盖了equals方法的类型，==比较存放内存地址，equlas是由覆盖后的代码决定。
4，String类型中equals比较的是两字符串内容是否相同

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>9， StringBuffer和StringBuilder的区别，从源码角度分析?</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，都被final所修饰，不能被继承，同时继承的类和实现的接口相同，两者在字符串的处理中的方法几乎是相同的。
2，底层都是用字符数组实现，字符串都是可变的；
3，StringBuffer线程安全，StringBuilder线程不安全。
4，StringBuffer相对StringBuilder的线程安全实现通常是在相同功能的方法上加上synchronized关键字
	StringBuff有缓存，比 StringBuilder多了char类型数组成员变量，在多次调用toString方法时，可以输出缓存的数据值，因此设计到buffer中字符串变化时，都需要清楚这个字段的数据。为了线程安全牺牲时间空间。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>10， 什么是自动拆装箱？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>JDK1.5以后引入；
装箱就是将基本数据类型转为包装类，拆箱就是将包装类转为基本数据类型。
底层调用的就是 valueOf（）和intvalue（）方法；

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>11， String.valueOf和Integer.toString的区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>String.valueOf()可以将任何数据类型，且不会由异常报出。
Integer.toString()表示先将int转为Integer型，然后再将Integer转为String，

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h3> <p>1，关键字有哪些</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public private defalut protected interface case try catch abstract boolean break continue double int flot final static void finally false true null native
总体来说Java关键字一共为53个，其中const，goto为保留字。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>2，浅谈fianl关键字？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>修饰类：类不可以有子类
修饰方法：最终方法不可以被覆盖
修饰局部变量：初始化后不可以改变
修饰成员变量：初始化后不可以改变
原理：被final修饰的赋予了putfiled指令，操作系统会在该指令后加入写屏障，保证其他线程读到他的值不会出现为9的情况；

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>3，volatile关键字了解多少？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，保证可见性，不保证原子性：
当写一个Volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中，这个写操作会导致其他线程中的volatile缓存无效。
2，禁止指令重排
volatile关键字底层使用内存屏障来实现
	确保指令重排不会将其后的指令排到内存屏障之前，也不会去将前面的指令拍到内存的内存屏障后面，读取时加入读屏障，强制读主。写入时写屏障，强制写主内存，其他的cpu对象缓存无效。
导致I++问题！

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h3> <p>1，集合有哪些？实现结构是什么？线程是否安全？如何让线程安全？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>常用的集合：List，set，Map的子类；
List：Arraylist，LinkedList，vector
Set：HashSet，SortedSet，TreeSet，LikedHashSet
Map：HashMap，SortedMap，Hashtable，treeMap

ArrayList：
底层实现：Object数组，默认大小为10，扩容是1.5倍。当add时容量不足是才会进行扩容，复制长度大1.5被之前数组长度，将元素复制新的数组中。同时ArrayList集合实现了RandomAccess，Cloneable，Serializable接口所以支持随机访问元素，克隆，序列化等。
优势：有序可重复，可存放多个null， 查询很快。
缺点：涉及到中间插入或是中间删除很慢，因为添加删除会导致大量的数组元前移，而且add可能会触发扩容。

浅复制：通过clone，将复制对象的引用
深复制：完全不同的两个对象

LinkedList：
底层：基于双向链表进行实现，包含两个重要成员：header和size是双向链表的表头，他是双向链表节点所对应的类Entry的实例，Entry中包含成员变量：previous，next，element。其中，preivous是该节点的上一个节点，next是该节点的下个节点，element是该节点所包含的值。size是双向链表中接待你的个数。
优势：顺序访问高效，随即访问效率低。中间添加删除的效率更高。
缺点：节点是分散在堆空间里面的，这时候CPU缓存帮不上忙，只能是去读取内存；

HashMap：
底层：有数组加单向链表（1.8尾插法），单项链表到达8时或长度为64转换为红黑树。链表的节点为Entry对象包含四个属性（hash，key，value，next）	。
扩容：无参构造中initCapacity数组为16，加载因子loadFactor为0.75，容器的阈值为 （initcapacity  * loadFactor）；	大于阈值才会进行扩容，为原先两倍。
1.7之前为头插法，在多线程中如果1再插入链表时2触发了扩容可能会导致死循环。（也就是在并发情况下ReHash可能会形成链表循环）
存储过程：通过hashMap自己提供的hash算法，算出当前hash值，根据hash值调用indexFor方法计算当前对象存储在数组的位置。判断size是否已经达到了当前阈值，如果没有，继续，如果达到阈值则将组长扩容为原来的2倍。（size是已有的entry数量不是数组长度）。将当前对应的hash，key，value封装为一个Entry。放在当前数组的位置，如果已经存在链表，则遍历链表。如果列表某个key与当前key进行equlas后结果为true，则将节点上的value返回，将当前value放。如果没有找到则将新封装的Entry指向当前链表的节点。
 解决HashMap链表死循环三种方法：
1，使用Collection.synchronized*(集合)将线程不安全的集合变为线程安全的集合，其中定义了对象锁来保护线程安全，将该对象转为同步对象，不能改变对象的类型性质。
2，使用HashTable，效率较慢。
3，使用JUC包下的concurrentHashMap。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>2， 为何HashMap的数组长度一定是2的次幂？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>底层的 与运算 16-1的二进制都是1，2的次幂-1，二进制也都是1，更好的去做定位运算。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>3， HashMap的key一般用字符串,能用其他对象吗？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>可以是其他对象，但必须时不可变的。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>4，聊聊并发容器！ConcurrentHashMap</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>JDK1.7，是由一个个Segment组成，Segment通过继承ReentrantLock来进行加锁，这样保证每个Segment是线程安全的，也就是实现了全局安全。
JDK1.8后concurrentHashMap屏蔽了Segment概念，而是直接使用Node数组+链表+红黑树的数据结构来实现，并发控制采用Synchronized+CAS机制来确保安全性，为了兼容旧版本暴露了Segment定义，虽然没有任何结构上的作用。
主要优化两个部分：
	1，放弃了HashEntry结构，采用Node数组+链表（链表长度大于8转为红黑树的形式）
	2，Synchronize代替了ReentrantLock，因为1.6以后内置的synchronize越来越轻和加锁力度不同，1.8的加锁力度就是hashEntry（首节点）也就是1.8中加锁力度更低了， 在粗力度加锁中ReentrantLock可能通过了Condition来控制各个低力度的边界，更加灵活，而在低力度中condition的优势没有了所以使用内置的synchronize并不比lock差。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>5，HashTable和HashMap实现原理有什么不同？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>hashTable不允许键和值为空，若为空则抛出空指针异常。
table使用模运算计算索引，map使用 h&amp;（length-1）
table若干方法都添加了synchronized关键字，意味着hashtable是个线程安全的类
table每次扩容是旧容量的2倍+2，而HashMap是就旧容量两倍。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>6， 聊聊你对数据结构的理解？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>数据结构，直白地理解，就是研究数据的存储方式。
我们知道，数据存储只有一个目的，即为了方便后期对数据的再利用，就如同我们使用数组存储 {1,2,3,4,5} 是为了后期取得它们的加和值，无缘由的数据存储行为是对存储空间的不负责任。

因此，数据在计算机存储空间的存放，决不是胡乱的，这就要求我们选择一种好的方式来存储数据，而这也是数据结构的核心内容。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>7， HashMap构造传参15，那么创建的长度为多少</p> <h3 id="io"><a href="#io" class="header-anchor">#</a> IO</h3> <p>1，IO主要分为那两类？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>字符流 字节流

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2，如何使用io将C盘文件copy到B盘？</p> <p>3，BIO，NIO，AIO</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  BIO(同步阻塞)：服务端需要对客户端每个请求处理完成后才会继续接收客户端的请求
  （叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。）
  NIO（同步非阻塞）：使用单线程或者只是用少量的多线程，一个请求一线程，多个链接共用一个线程。
  （叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。）
  AIO(异步非阻塞):读写方法都是异步的完成后会主动调用回调函数
  （每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。）

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="线程"><a href="#线程" class="header-anchor">#</a> 线程</h3> <p>1，线程与进程</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>进程：是资源分别分配的单位，是程序执行时的实例。程序运行时系统就会为其创建进程，并为他分配资源，然后将进程放入到就绪队列，进程调度器选中它是就会为它分配资源，程序开始真正运行。一个进程可以由多个线程，但至少由一个线程。
线程：是程序执行最小单元，是一个进程的执行流，CPU调度基本单位。一个进程有多个线程组成，线程间共享进程所有资源，每个线程有自己的堆栈和局部变量。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>2，线程六大状态</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>创建：使用new操作符创建一个线程，还未运行。
就绪：调用了线程的start()方法，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方	法返回后，线程就处于就绪状态。
运行：当前线程获得CPU时间后进入运行状态。
阻塞：由于执行过程中的各种原因进入阻塞状态 sleep 锁被持有 等待触发条件等
死亡：run()方法执行完毕，未捕获异常导致

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>3，线程创建的方式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，extends Thread 2，interface Runnble 3，使用Callable和Future创建（get()具有返回值）4,Executor线程池

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>4，线程池的7大参数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>核心线程数，最大线程数（CPU密集型/IO密集型），多余线程存活时间，时间单元，阻塞队列，线程创建工厂，拒绝策略
CPU密集型：根据CPU线程数来确定，CPU使用率高
I/O密集型：CPU使用率低，多少个文件处理就开辟多少线程进行执行

如何配置线程池的大小：
1，高并发，任务执行时间短的，线程数设置CPU+1,减少上下文切换
2，并发不高，任务执行长根据业务区分：
	a):业务长时间几种在IO操作，加大线程数，让CPU处理更多业务，不要让CPU停下
	b):业务执行时间几种计算上，减少线程数，让CPU避免上下文切换。
3，并发高，业务执行长。这个类型任务关键不在线程池而在整体架构，（是否能做缓存，增加服务）

任务进入线程池的过程：
一个任务进入线程池发现线程池是空的，就会创建线程执行任务，如果核心线程数满了进入队列等待，如果队列满了则开启最大线程数处理任务，如果此时队列也满了就会执行拒绝策略。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>5，线程的常用的三个工具</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，CountDownLatch 同步倒数计数器：一个或多个线程等待其他线程完毕后。countdownlatch内部有计数器，调用countDown方法就会减1，到0时所有等待者停止等待。
2，CyclicBarrier 同步加法计数器：一个或多个线程，全部完毕后才开始执行，否则陷入等待。
3，Semaphore信号量：用于控制并发线程数，类似停车场一样。内部维护了一个许可集。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>6，四个拒绝策略是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>AbortPolicy：直接抛出异常
CallerRunsPolicy：不抛弃任务也不抛出异常，将某些任务退回调用者
DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务
DuscardPolicy：直接丢弃任务，不处理也不抛异常
自定义拒绝策略：比如一些重要的线程丢弃掉会造成很多问题，可以根据业务的情况来进行一个自定义策略。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>7，如何解决线程安全性？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>并发编程中三个核心概念：可见性，原子性，有序性。
当多个线程操作同一个变量时，如果这个变量没有任何约束，或者操作的代码没有任何锁机制，就会出现线程安全问题，导致最终结果不一致。经典i++问题；
可以使用Java操作原子性工具锁和同步方法或同步代码块。
可以使用JUC原子类保证原子性，volatile保证可见性，锁保证原子性。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>8，为什么线程启动使用start（）方法？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>因为run（）方法只是普通方法直接调用，程序依然只有主线程一个线程，而start（）方法使该线程开始执行，java虚拟机调用该线程的run（）方法，才是真正多线程。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>9，三种方式实现生产者消费者模式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1,Object的wait()/notify()方法
	wait()当缓冲区已满/空时，生产者/消费者线程停止自己的执行，放弃锁，使自己处于等待状态，让其线程执行。notify()当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。
2，Lock的Condition的await(）/signal()方法
	使用condition可以更加细粒度的控制。await()和signal()方法功能基本与Object的wait()和notify()方法相同，可以完全取代。通过Lock对象调用newCondition()方法，将条件变量和一个锁对象继续绑定，进而控制并发程序访问竞争资源的安全。
3，BlockingQueue阻塞队列方法

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>10，Java用到的线程调度算法？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>所谓多线程并发运行，就是线程轮流获取CPU执行权执行各自的任务,JVM有一项任务就是负责CPU的调度，线程调度就是按照特定机制为多个线程分配CPU使用权。
分时调度：让线程轮流获得CPU使用权，平均分配到各个线程占有CPU时间片。
抢占式调度：java采用。优先让线程池中优先级别高的线程首先占用CPU，如果优先级别相同则随机选择线程。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>11，sleep()和wait()有什么区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>sleep（）属于Thread下静态方法，不释放锁，可以指定时间苏醒并进入就绪状态
wait（）方法属于Object类下，释放锁，需要被notify或notifyall唤醒，苏醒后进入没有锁就进入阻塞有锁则进入就绪

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>12，ThreadLocal实现原理？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>每个线程内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个变量键值存储当前ThreadLock变量，value为变量副本。
初始时，threadLocals为空，当ThreadLoacl调用get或set方法时，才会对threadLocals初始化，当前ThreadLocal变为键值，要保存的副本变量为Value，存入到threadLocals当中。

ThreadLocal什么时候会出现OOM的情况？为什么？
ThreadLocal中存在一个弱引用ThreadLocalMap，其中每个Key为TrheadLocal实例。这个Map确实使用弱引用，不过只针对key，所以将threadlocal实例置为null后，threadlocal会被GC回收，但是value却不能回收，但是value永远不会被访问到所以存在内存泄露。
因为存在一条current thread链接过来的强引用，只有当前thread结束以后，current thread就不会再栈中，强应用断开则current Thread，map value都会被GC，所以最好使用threadloacl的remove方法。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>13，（AQS ）AbstractQueuedSynchronizer源码阅读吗，请说说实现原理？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>AbstrctQueuedSynchronized为抽象的队列同步器，用来构建锁或者其他同步器组件的重量级基础框架是整个JUC体系的即使，通过内置的FIFO双向链表队列来完成资源获取线程的排队工作将其分为内一个一个node然后从尾部添加，并通过一个int类型变量（state）表示池有锁的状态。
原理：
AQS为实现阻塞锁，依赖先进先出的一个等待依靠一个原子int值来表示状态，通过占有和释放方法，改变状态值AQS使用一个Volatile修饰的int类型表示同步状态，通过内置的FIFO队列来表示完成获取资源的排队工作，将每条要去抢占资源的线程封装为一个Node节点来实现所锁的分配，通过CAS完成对State值的修改。
核心思想：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
AQS使用了模板设计模式，比如重入锁和读写锁还有semaphore，CountDownLatch都是实现这个AQS的一个子类，所以AQS的方法定义没有默认实现需要子类实现。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>14， 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>因为Java提供的锁是对象级不是线程级别，每个线程都有锁，通过线程获得。而如果线程需要等待锁调用对象中的wait方法就没有意义，而wait方法定义在Thread类中，线程等待的是那个锁又不明显。
简单讲：wait，notify，notifyall都是锁级别操作，所以定义在Object中因为锁属于对象。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>15，线程池启动线程submit和execute有什么不同？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>submit有返回值，方便异常处理。execute没有返回值。接收参数也不一致

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h3> <p>1，Java中有哪些锁概念？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>乐观锁，悲观锁，公平锁，非公平锁，可重入锁，不可重入锁，共享锁，排他锁，分段锁

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2，Java中由哪些锁？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>synchroized：非公平，可重入锁，悲观锁，独享，互斥
ReentrantLock：公平/非公平，悲观，独享，互斥，可重入
ReentrantReadWriteLocK：公平/非公平，配管，写独享，读共享，可重入。
ReadLock：读锁
WariteLock：写锁

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>3，ssyncharized锁特点？原理？1.5升级后的过程是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>sybchronuzed锁在jdk1.6以后进行优化，性能与lock所以一致。
1.6以后synchronized存在四种状态 无锁 偏向锁 轻量锁 重量级锁；随着竞争状态逐渐升级，锁可以升级但不可以降级，但是偏向锁可以被重置为无锁状态。偏向锁为了解决大部分情况下锁会被一个线程所获的，避免锁争抢。偏向锁并不会释放锁！

锁升级过程
无锁：锁对象初始化时，锁对象处于无锁状态
偏向锁：如果一个线程获取锁，则锁进入偏向锁状态。当这个线程再次获取到锁无需做任何用户操作即可获得，避免大量申请锁操作。
轻量级锁：偏向锁失败，多线程轻度竞争升级为轻量级锁。竞争的线程自旋，进行CAS操作。（1.6后加入自适应自选，由jvm自行控制自旋次数）线程较少占有时间较短可以提高效率）
重量级锁：多线程重度竞争升级为重量级锁，切换为内核态向操作系统进行申请锁，进行锁分配。等候线程进入阻塞队列。

synchronized：基于进入与退出Moniter对象实现方法与代码快同步，监视器锁还是依赖于底层的mutex lock（互斥锁）。
Monitor.Enter和Monitor.Exit就是作用在JMM中定义的内存操作中的lock和unlock上面。一个变量在同一时刻只允许一条线程对其进行lock操作，lock操作的时候会清空工作内存，重新去主内存load最新的数据。Unlock操作则会执行store和write操作将工作内存中的数据写回主内存。这也就是为什么我们用了Synchronized关键字之后就能够实现线程安全。
 synchronized是java的关键字，无需手动释放锁，不可中断对锁的获取，锁状态也无法获取，是非公平 可重入 不可中断 适合少量的代码快同步操作。

从jvm层面分析sychronuzed如何保证线程安全？
java中每个锁对象都有一个对象头，包含Mark word的重要信息，执行monito.enter ：首先判断状态是否是偏向锁，若是偏向锁Mark word锁还会记录线程ID，接着会比较这个线程ID。使用CAS如果成功则执行代码块，否则表示多个线程争抢锁，将到达全局安全点的获得偏向锁的线程挂起，升级为轻量级锁。升级完成后被挂起的线程执行；通过CAS尝试将Mark word更新指向，如果成功则获取到锁进行执行，否则Mark word就处于加锁状态且ptr指针指向当前线程栈帧的执行代码块，否则说明多个线程竞争轻量级锁膨胀为重量级锁。
重量级的

升级后执行过程：当线程A加锁成功后变为偏向锁（对象头中有个区域存放线程id，线程只管设置不负责清楚），线程B进入使用CAS来尝试替换如果替换成功则还是偏向锁状态，如果失败，则进入jvm的waitSet进行等待（而entrySet则是进运行时区域），若有现成竞争则变自旋状态，而CAS十次以上则会变为重量级锁；

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>4，lock锁</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>可重入锁

公平锁：一开始没有队列，如果一个线程进来发现锁正在被占用则会查看是否存在队列，如果没有队列则创建一个队列，如果有队列则直接进入队列进行等候；

非公平锁：直接使用CAS替换自己， 在线程A执行完毕线程B准备执行时可以替换成功，如果第一次没有抢成功就去入队，入队时候在CAS一下如果还没有成功则进入等待唤醒；为什么要入队前在cas一下，由于沉睡唤醒太消耗时间，处于性能考虑在沉睡前再次替换一下；

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>5，请谈谈什么是CAS?</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Compare and swap 比较替换，先去比较期望值是否等于要更新的变量，如果等于就执行复制操作，否者就不操作。也可以尝试重复操作，也可放弃，属于乐观锁的实现，天然免疫死锁。Java本身无法实现，通过本地方法调用来进行实现操作。
CAS是一种系统原语，是一条CPU的原子指令，不会造成数据不一致问题。
存在问题：1，ABA问题 2，CPU消耗大 3，不保证原子性

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>6，读写锁如何实现？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> 读写锁同样同样依赖于AQS，它有公平锁与非公平锁（默认）的概念，主要继承于Sync实现。AQS的状态时state的关键在32为int类型，分为两半，读锁用高16位表示持有的读锁的线程数，写锁用低16位表示写锁的重入次数。状态为0表示锁空闲，sharedCount不为0表示分配了读锁，exclusiveCount不为0表示分配了写锁。sharedCount和exclusiveCount一般不会同时不为0，只有当前线程占有了写锁，该线程可以重入获取读锁，相反不成立。
 公平锁：当线程发现有线程在排队获取锁，那么他必须排队获取锁。除非线程已占有锁或是可重入锁
 非公平锁：只有一种情况需排队，其他情况不用排队就可以尝试获取锁，如果当前是无锁状态，被线程获取为读锁后，如果后面是读锁那么都可以获得。但是如果读锁状态队列第一个线程想尝试获取写锁，而后面读锁到来发现首节点是写锁那么读锁也需要进行排队。（主要为了避免读锁一直获取写锁一直获取不到的情况）

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式：</h3> <p>1，设计模式六大原则</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>开放封闭原则：进来通过扩展实体来解决需求变化而不是修改代码。
里氏代换原则：使用的基类可以在任何地方使用继承的子类，完美的替换基类。
依赖倒转原则：依赖倒置原则的核心思想是面向接口编程.
接口隔离原则：比如支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口
迪米特法则：一个对象应当对其他对象有尽可能少地了解，简称类间解耦
单一职责原则：一个方法只负责一件事情，降低类和类的耦合。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>2，常用得设计模式？</p> <p>3，手写设计模式？（代理模式，单例模式，责任链模式）</p> <p>4，设计模式的作用</p> <p>5，什么是设计模式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>5，Java什么是单例模式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>6，说一个你熟悉的设计模式吧？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>工它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式
好处：
工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。
利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。
将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>7，手写设计模式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="排序算法"><a href="#排序算法" class="header-anchor">#</a> 排序算法：</h3> <p>1，常用的排序算符</p> <p>2，时间复杂度与空间复杂度</p> <p>3，排序算法有哪些</p> <h3 id="jvm"><a href="#jvm" class="header-anchor">#</a> JVM</h3> <p>1，JVM内存区域如何划分？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>分为9块：类加载系统，Java栈，本地方法栈，PC寄存器，方法区，堆内存，直接内存，垃圾回收，jvm引擎。
1，类加载系统：加载Class文件并保存到方法区
2，Java栈：存放局部变量，对象引用，执行Java方法
3，本地方法栈：执行本地方法栈（nativeMethod）
4，PC寄存器：区分本地方法和普通方法
5，方法区：存放类的字节码文件，字符串常量字面量
6，堆内存：new出来的对象都在堆内存
	默认情况下：（老年代：2/3的堆空间， 年轻代：1/3的年轻代空间(eden区：8/10年轻代空间，survivor0：1/10的年轻代空间，survivor1：1/10的年轻代空间)）
7，直接内存：堆外内存，效率高，必要时候使用
8，垃圾回收系统：回收算法（标记回收，复制算法，标记压缩）

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>2，三种类加载器？双亲委派机制？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>类加载器分为：BootStrap启动类，Extension扩展类加载器，Application应用程序类加载器，Custom Class Loader自定义类加载器。
BootStrapClassLoader：负责加载JVM自身需要的类，由C++实现。加载的是JAVA_HOME/lib下的class文件。
Extension：扩展类加载器，被BootStrapClasLoader加载器加载。负责加载JAVA_HOME/jre/lib/ext路径下的类
AppClassLoader：系统加载器，被BootStrapClasLoader加载器加载。负责加载classpath路径下的类。（对于Eclipse来说就是项目路径/bin目录，bin目录装运行用的字节码文件，项目src下装的是源代码。

双亲委派机制：
当加载Hello.class时，先到AppClassLoader中检查是否加载过，若加载过则无需再次加载，若未加载就会拿到父加载器（ExtClassLoader），调用父类加载器的loadClass方法，父类加载器也会检查自己是否加载过若加载则无需再次加载，若未加载获取父类加载器（BootStrapClassLoader）进行加载。而BootStrap加载器已经没有父类加载器，如果自己无法加载则下沉到子加载器进行加载，一直到最底层，如果没有加载器可以加载则抛出ClassNotFoundException异常。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>3，堆中对象如何创建？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，类加载检查
2，为对象分配内存：对象所需内存大小由加载后决定，相当于把一块确定大小的内存从Java堆中划分出来
	堆内存是否规整存在两种内存方式(堆规整是有采用垃圾回收器是否代压缩整理功能决定)
	指针碰撞：Java堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离。例如：Serial、ParNew等收集器。
	空闲列表：Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，就没有办法简单的进行指针碰撞了。虚拟机必须维护一张列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。例如：CMS这种基于Mark-Sweep算法的收集器。
3，内存空间初始化：保证对象的实例化字段在Java代码中可以不赋值就可以使用，程序可以访问到数据类型对应的0值
4，对象设置
5.init

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>4， JVM对象的结构？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>三部分：对象头（Header)，实例数据（Instance Data)，对齐填充
对象头：HotSpot虚拟机的对象头主要包含两部分信息。
	a.存储对象和自身的运行时数据，如hash码，GC分代年龄，锁状态表示，线程持有锁，偏向线程ID等。
	b.存储类型指针，对象指向他的类元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。
实例数据：对象真正存储的有效信息，也就是程序代码中所定义的各种类型的字段内容，hotSpot虚拟机默认分配策略为longs/doubles,ints,shorts/chars,bytes/booleans,oop从分配策略中可以看出，相同宽度字段总是分配到一起。
对齐填充：并不是必然存在，也没有特定含义，仅仅有着占位符作用。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>5，Java垃圾回收机制</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Java中不需要显示的释放一个对象的内存，而是由虚拟机自行执行。JVM中有一个垃圾回收线程（GC）为低优先级，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>6，垃圾回收机制算法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，标记-清除算法(Mark Sweep)：最简单容易实现，分为两阶段：标记阶段和清除阶段；标记阶段将所有需要回收的对象标记，清除阶段就是回收所有被标记对象。容易产生垃圾碎片，导致后续过程中无法为大对象分配内存空间从而再次触发垃圾收集动作。

2，复制算法（Copying）：将可用内存分为相等两块，每次使用一块，一块内存用完后将存货对象复制到另一半内存后再将使用过的内存清理掉。避免了垃圾碎片的产生，但是严重浪费空间和需要大量复制操作，如果存货对象多效率变差。

3，标记整理算法（Mark Compact）压缩法：为了解决Copying算法缺陷，先可回收对象，然后将存货对象向另一段转移后清掉边界意外的内存。

4，分代收集算法：目前大部分JVM采取的算法，核心思想：根据存活对象的周期划分不同的区域，一般情况下划分老年代和新生代，老年代特点每次回收只有少量对象被回收所以采用标记整理算法（压缩法），新生代特点每次回收都有大量回收的对象所以采用Copying算法。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>7，JVM垃圾回收如何判断是否是垃圾对象？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>本质是当堆内存的对象没有被任何引用的时候就会被回收。
引用计数算法：在对象中添加一个引用指针，当有地方引用这个对象时，引用计数器加１，当引用失效的时候，引用减１。当引用计数器的值为０时，JVM就开始回收这个对象。也就是栈指向堆指向这个对象时加１，栈指向为ｎｕｌｌ时引用计数器就减１。
问题：当对象之间相互指向时，两个对象引用计数器的值都会加１，而由于两个对象是相互指向，所以引用不会失效这样JVM就无法回收。
可达性分析算法：针对引用计数算法的BUG，JVM用了比较实际的方法，顶一个&quot;Gc Roots&quot;对象作为起始点，这个GC对象可以有多个。从这些节点开始向下搜索，搜索所走过的路径为引用链，当一个对象到GC Roots没有任何引用链时，则证明此对象时不可用，进行垃圾回收。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>8， JVM可以作为GC Root的对象有哪些？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>虚拟机栈中引用的对象 方法区类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(navite)引用对象

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>9， 请写出几段可以导致内存溢出、内存泄漏、栈溢出的代码？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>堆溢出:
public static void main(String[] args) {
    List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
    int i=0;
    while(true){
        list.add(new byte[5*1024*1024]);
        System.out.println(&quot;分配次数：&quot;+(++i));
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>10，GC是什么时候触发的？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>由于对象的分代处理，垃圾回收区域，时间也不一样。GC有两种类型：Scavenge GC和Full GC;
Scavenge GC：新对象生成并在Eden申请空间失败时触发，堆Eden区域进行GC，清除非存活对象同时将存活对象转移Survivor区，然后整理。这种方式GC是对年轻代的Eden区域进行，不会影响老年代。因为大部分对象都是从Eden开始，所以Eden区域不大，会频繁GC。
Full GC：对整个堆进行整理，包括Young，Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC更慢所以尽量减少FullGC次数。
	导致Full GC原因：老年代，持久代，System.gc()等都会触发。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>11， 频繁GC问题或内存溢出问题，如何定位？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>一个是arthas（阿里巴巴），另一个是jdk自带的工具jmap 。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>12， Java中的引用？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>强引用： Object obj = new Object() 强引用不会被GC回收。
软引用：来描述一些有用单并非必须的对象。在系统将要发生益出异常之前，将会把这些对象列回回收范围。
弱引用：来描述非必需的对象，比软引用更弱，只能生存在下次垃圾收集之前。当垃圾收集器都会回收。
虚引用：最弱的引用关系，一个对象是否存在虚引用，对生存时间不会构成影响。作用在这个对象被收集器回收之前收到系统通知。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>13，JVM调优</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>jvm调优时机：调优并不是常规手段，性能问题一般第一选择优化程序，最后才选择JVM调优。
1.老年代持续上涨达到最大内存值。
2.Full GC次数频繁。
3，GC停顿时间过长（超时1秒）
4，应用出现OutOfMemory等内存异常；
5.应用中使用本地缓存占用大量内存空间
6.系统吞吐量与性能不高或下降。
jvm调优目标：
老年代的使用率&lt;=70%，Old generation内存使用率&lt;=70% avgpause &lt;= 1秒 Full gc 次数0 或 avg pause interval &gt;= 24小时

调优步骤：
分析系统系统运行情况：分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；
确定JVM调优量化目标；
确定JVM调优参数（根据历史JVM参数来调整）；
依次确定调优内存、延迟、吞吐量等指标；
对比观察调优前后的差异；
不断的分析和调整，直到找到合适的JVM参数配置；
找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。
以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>14，http和https协议有什么区别</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，HTTPS协议需要到证书颁发机构CA申请证书，HTTP不用申请证书；
2，HTTP是超文本传输协议，HTTPS 则是具有SSL加密的安全性传输协议
3，HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4，Http是无状态拦截，https协议是ssl+http协议构建的可进行加密传输，身份认证的网络协议更安全。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>15，TCP三次握手</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>开始开户段都是closed，然后服务端监听某个端口进入listen状态
第一次握手发送完毕后客户端进入发送状态
第二次握手发送完毕后服务端进入收到状态
第三次握手发送完毕后客户端进入确立状态，服务端收到后也进入确立

因为三次握手已经可以确保双方建立链接，少一次就少了一方确认，多一次确认又多余。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>16，TCP挥手为什么需要四次呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。
（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>17，TCP 和 UDP 的区别</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>TCP面向连接;UDP是无连接的
TCP要求安全性，提供可靠的服务，通过TCP连接传送的数据安全可靠。而UDP尽最大努力交付，即不保证可靠交付。
TCP是点对点连接的，UDP一对一，一对多，多对多都可以
TCP传输效率相对较低,而UDP传输效率高，它适用于对高速传输和实时性有较高的通信或广播通信。
TCP适合用于网页，邮件等;UDP适合用于视频，语音广播等
TCP面向字节流，UDP面向报文

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>18，TCP 是如何保证可靠性的？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>TCP的连接是基于三次握手，而断开则是四次挥手。确保连接和断开的可靠性。
TCP的可靠性，还体现在有状态;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="mysql"><a href="#mysql" class="header-anchor">#</a> Mysql</h1> <p>1，数据库的SQL注入</p> <p>2，数据库三大范式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，每一个字段不可再分
2，非主键列完全依赖于主键，不可产生部分依赖
3，非主键列只能依赖于主键列，不可依赖其他非主键

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>3，Mysql数据库隔离级别</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>读未提交：select语句不加锁
读已提交：普通select语句快照读，加锁的select update delete语句检查外键约束，重复键检查时封锁区间，其他时刻使用记录锁。
不可重复度：普通select语句使用快照读mvcc实现，加锁的select的锁依赖于是否是唯一索引使用了唯一查询条件
序列化：select语句都会被隐式转为select inmode，而有未提交事务被阻塞

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>4，数据库SQL执行过程？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，先建立链接数据库，先进行认证，再认证是否具有特定查询条件
2，查询缓存mysql但是8.0版本mysql缓存已经被清除。
3，分析器将SQL关键字分析出来，进行语法分析生成句子以及确保语句可执行后进行代码生成。
4，优化器：经过分析器后直到了你想要什么，优化器判断可以使用的索引，以及句子的执行顺序等。
5，执行器先判断是否有table查询权限，根据引擎定义使用引擎提供的接口。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>5，主从复制原理</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>主库写操作被写入binlog日志，从库链接主库，主库创建一个binlog dump thread把内容发送到从库，从库创建I/O线程读取主库过来的binlog内容写入relay log日志，在创建SQL线程将relay log日志从Exec_master_log_Pos位置开始执行读取到的更新事件，更新到slave。

主从复制延迟原因：因为服务器开发大量链接给客户端，但是写binlog线程只有一个，某个sql执行或锁表就会导致主服务器大量堆积，未被同步导致主从不一致。

解决：没有很好解决方案：忽略 强制读主 或 选择性读主
利用缓存记录必须读主的数据，写主库将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延”。当发生读请求则到chache查询，有就代表发生过写请求，查主库，如果没有则差从库。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>6，索引方面</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>	索引注意点？
	索引失效：查询条件为范围查找，隐式类型转换，函数运算，like做前缀匹配，不遵循左前缀匹配原则，列运算，is null，is not nul等等
	不适合建立索引的情况：写操作频繁，数据量少，离散型低
	最左匹配原则：是建立的索引与查询字段的首字段比配，遇见范围查询结束索引匹配
	索引有哪些？
	主键索引，唯一索引，不同索引，全文索引，覆盖索引，组合索引

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>7，MyISAM与Innodb引擎的区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>MyISAM：全文检索，表锁，非聚簇索引，读取速度快，表空间占用大。
Innodb：事务，外键，表锁，行锁，全文索引，写操作效率高，表空间占用小，聚簇索引。

聚簇索引：聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。
访问更快但是插入速度依赖于插入顺序，二级索引需要两次索引查找（先找到主键值，再根据主键找到数据行）；
非聚簇索引：表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>8，锁的类型？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>粒度分：
	表锁：锁粒度最大的一种，对整张表加锁，实现简单，资源消耗少，但造成冲突更多。
	行锁：锁粒度最小，对行数据加锁，开销大但是数据库操作冲突更少。
	页锁：只有BDB支持。
级别分：
	共享锁（读锁）：允许多个线程读，写操作进入阻塞。
	排他锁（写锁）：只允许一个线程操作。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>9，不考虑隔离性容易出现什么情况？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。
不可重复读 ：是指在一个事务内，多次读同一数据。
幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>10，事务的要素？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ACID:原子性：要不一同成功要不一同失败，不会听停在中间环节。隔离性：一事件只允许一个事务访问同一条数据，不同事物之间不存在干扰。持久性：事务所提交的数据被持久化到硬盘。一致性：事务开始前结束后，数据库完整性约束没有被破坏。

事务ACID的实现思想？？？
原子性使用undo log实现，如果事务执行中出错或者执行rollback将通过undo log日志回到事务开始状态
持久性使用redo log只要日志持久化了那么系统崩溃也能通过redo log来恢复数据
隔离性通过锁以及MVCC使用事务相互隔离
一致性通过回滚回复以及并发下的隔离性实现一致性

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>11，事务传播行为？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>requried：如果当前存在事务就加入事务，不存在就创建事务
supports：支持当前事务，没有事务就非事务执行
mandatory：支持当前事务，不存在事务就抛出异常
requires-new：无论是否有事务都新建事务
not-supported：非事务运行，有事务就挂起。
never：非事务运行，有事务就抛异常
nested：当前存在事务，就嵌套事务，如果没有事务就与requried一致

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>12，什么是B-Tree</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>就是B树，常用于实现数据库索引因为查询效率高。
m阶B树满足4个人条件：
1，每个节点最多拥有个m个树。
2，根节点至少有2个子树
3，分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）
4，所有叶子节点都在统一层，每个节点最多可以有m-1个Key，并且以升序排序
另外B树种一个节点中可以存放很多的key（个数由树阶决定）。
相同数量的key在B树中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘IO的次数。这样到达一定数量后，性能的差异就显现出来了。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>13，什么是B+Tree？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>是B树的变种，比B树更高的查询性能
1，有m个子树的节点包含有m个元素
2，根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中
3，所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或最小元素
4，叶子节点会包含所有的关键字，以及指向记录的指针，并且叶子节点本身是根据关键字大小从大到小排序。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>14，B+Tree优势？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>B+Three范围查找，定位main和max之后中间叶子节点就是结果集，不是中序回溯。且读写能力更强，（叶子节点不保存真实数据，因此一个磁盘块能保存的关键字更多，因此每次加载的关键字越多）B+Three扫表和扫库能力更强（B-Tree树需要扫描整颗树，B+Tree树只需要扫描叶子节点）

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>15，分库分表设计？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>垂直切分：
	垂直分库：将表中关联度低的表存储到不同数据库。可按业务分类进行独立划分，类似微服务治理。
	垂直分表：将表中字段多的表，为其建立扩展表将不常用字段内容过长的放入扩展表。大表拆小表方便维护开发，避免跨页问题。
水平切分：
	分库分表：表内数据内在的逻辑关系，将不同一个表按不同的条件分散到多个数据库或多个表中，使得单个表的数据量变小
	库内分表：将字段按活跃度拆分不同表当中。

存在问题：分布式事务，跨界点join，ID问题（切分后不在依赖数据库主键），跨节点的order by group以及聚合函数问题，跨分片的排序分页问题。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>16，如何选择合适的分布式主键方案？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>数据库自增，uuid，雪花算法，redis生成id，zookeeper生成唯一id

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>17，MVCC底层原理？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>MVCC多版本控制器，在同一时间，不同事物可以读取到不同版本的数据库，从而解决脏读和不可重复读。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>18，一条SQL执行过长如何优化？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，查看是否涉及多表和子查询，优化SQL机构，去除冗余字段，是否可拆表。
2，优化索引结构，是否可以添加索引。
3，数据量大的表，考虑分离或分表。
4，数据库主从分离，读写分离。
5，explain分析Sql语句，查看执行计划优化Sql。
6，查看Mysql日志，分时是否存在其他问题。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>19，如何加锁？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>如何添加共享锁（S锁/读锁）？select语句添加Lock in share mode；
如何添加排他锁（X锁/写锁）？select语句后添加for update
注意：innodb中锁添加的是行锁或表锁，在于语句是否使用了索引（使用索引则是行锁）否则是表锁！！！
    select语句默认不会加任何锁类型。update，delete会默认添加排他锁（next key），而insert语句会添加gap锁（insert intention gap））；

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>20，Hash索引和B+Three区别是什么？如何选择？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>B+树可以进行范围查询，Hash索引不能。
B+树支持联合索引的最左侧原则，Hash索引不支持。
B+树支持order by排序，Hash索引不支持。
Hash索引在等值查询上比B+树效率更高。
B+树使用like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，Hash索引根本无法进行模糊查询。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>21，主从复制binlog格式有哪几种？有什么区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>①STATEMENT，基于语句的日志记录，把所有写操作的sql语句写入 binlog （默认）
例如update xxx set update_time = now() where pk_id = 1，这时，主从的 update_time 不一致
优点：
成熟的技术。
更少的数据写入日志文件。当更新或删除影响许多行时，这将导致 日志文件所需的存储空间大大减少。这也意味着从备份中获取和还原可以更快地完成。
日志文件包含所有进行了任何更改的语句，因此它们可用于审核数据库。

缺点：
有很多函数不能复制，例如now()、random()、uuid()等

②ROW，基于行的日志记录，把每一行的改变写入binlog，假设一条sql语句影响100万行，从节点需要执行100万次，效率低。
优点：可以复制所有更改，这是最安全的复制形式
缺点：如果该SQL语句更改了许多行，则基于行的复制可能会向二进制日志中写入更多的数据。即使对于回滚的语句也是如此。这也意味着制作和还原备份可能需要更多时间。此外，二进制日志被锁定更长的时间以写入数据，这可能会导致并发问题。

③MIXED，混合模式，如果 sql 里有函数，自动切换到 ROW 模式，如果 sql 里没有会造成主从复制不一致的函数，那么就使用STATEMENT模式。（存在问题：解决不了系统变量问题，例如@@host name，主从的主机名不一致）

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>22，Mysql主从复制方式？有什么区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>①异步复制
网络或机器故障时，会造成数据不一致
②半同步复制（MySQL 8.0还支持通过插件实现的半同步复制接口）
③延迟复制

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>23，InnoDB内存结构包含四大核心组件？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>24，索引优缺点？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>优点
    唯一索引可以保证数据库表中每一行的数据的唯一性
    索引可以加快数据查询速度，减少查询时间
缺点
    创建索引和维护索引要耗费时间
    索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间
    以表中的数据进行增、删、改的时候，索引也要动态的维护。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>25，如何创建索引？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>使用alter table命令添加
使用create index命令添加

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>26，覆盖索引，回表？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>覆盖索引： 查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。
回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>27，. B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。
当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>28，组合索引是什么？为什么需要注意组合索引中的顺序？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>组合索引，用户可以在多个列上建立索引,这种索引叫做组合索引。 因为InnoDB引擎中的索引策略的最左原则，所以需要注意组合索引中的顺序。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>29，Innodb引擎中的索引策略？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>覆盖索引：是指在不同索引树中可以得到查询的结果，不需要回到主键索引书中再次搜索，覆盖索引时常有的数据库优化技术，可以极大提高性能主要有几个原因
    1，减少树的搜索次数，显著提升查询性能
    2，索引是按照值的顺序存储，所以对于I/O密集型的范围查询比随机从磁盘中读取每一行I/O要少得多
    3，索引条目远少于数据的条目，在索引树上读取会极大的减少数据库访问时间
最左前缀原则
    最做前缀原则建立联合索引之上，若建立了联合索引，我们不需要使用索引的全部定义只要用到了索引中最左边的那个字段就可以使用索引，这就是B+Tree索引支持最左前缀原则。
        维护索引需要代价，所以有时候我们可以利用“最左前缀”原则减少索引数量。
索引下推
    Mysql在5.6引入的可以在索引遍历过程中对索引包含的字段先做判断直接过滤掉不满足条件的记录，减少回表次数。
什么是回表？
数据库根据索引（非主键）找到了指定的记录所在行后，还需要根据主键再次到数据块里获取数据。
如何避免？
将需要的字段放在索引中去。查询的时候就能避免回表。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>30，Mysql索引排查？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>排查死锁步骤：
查看死锁日志show engine innodb status；
找出死锁SQL
分析SQL加锁情况
模拟死锁案发
分析死锁日志

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>31，什么是索引？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>索引本质就是排序

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>什么情况下行锁变表锁？
在MySql的写语句中，给表列赋值与表类型不符合时，MySql底层的优化器发挥作用，会做一个强制类型转化，此时能正常操作，但会导致行锁升级为表锁。

什么情况下会出现间隙锁？
封锁记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引的之后的范围，为了防止在其他事务在间隔中插入数据，导致头一个数据执行的SQL会出现幻影数据。

谈谈你对MySQL的in和exists用法的理解？
外查询表大，子查询表小，选择IN；外查询表小，子查询表大，选择EXISTS；若两表差不多大，则差不多。简单说就是小表驱动大表，本质就是减少IO次数。
count(*)、count(列名)和count(1)的区别？
count(*)：包含所有列，相当行，不会忽略null。
count(1)：忽略所有列，用1代表代码行，不会忽略null
count(列)：只有指定列，忽略为null的列

MySQL的数据库引擎有哪些，如何确定在项目中要是用的存储引擎？
MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。

union和union all的区别？
1、对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。
2、对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。
从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL

分布是系统如何保证接口幂等性？
所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款，不能多插入一条数据，不能将统计值多加了1。这就是幂等性，不给大家来学术性词语了。
其实保证幂等性主要是三点：
（1）对于每个请求必须有一个唯一的标识，举个例子：订单支付请求，肯定得包含订单id，一个订单id最多支付一次，对吧
（2）每次处理完请求之后，必须有一个记录标识这个请求处理过了，比如说常见的方案是在mysql中记录个状态啥的，比如支付之前记录一条这个订单的支付流水，而且支付流水采
（3）每次接收请求需要进行判断之前是否处理过的逻辑处理，比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。

数据库存储日期格式
datetime适合记录数据的原始的创建时间，修改记录中其他字段的值，datetime字段的值不会改变，除非手动修改它。
timestamp类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，timestamp字段的值都会被自动更新。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h2 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h2> <p>1，什么是Redis？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>2，为什么使用Redis？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>操作缓存块，有效减轻数据库压力，提高响应速度。对于分布式和高并发场景下Redis也可以解决一些棘手问题。

为什么使用Redis而不是hashMap或memcached做缓存
hashMap在分布式多实例情况下各自保留一份缓存，不具备一致性。
memcached不够了解未使用过。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>3，Redis为什么这么快？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>完全基于内存，数据结构简单经过设计的，多路复用IO，单进程单线程避免上下文切换，Redis自己构建了VM机制，因为一般的系统调用系统函数会浪费一定时间去移动和请求。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>4，Redis可以应用的环境？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>缓存，会话缓存，全页缓存，消息队列(订阅/发布)，分布式锁（Setnx），共同好友（Set交集）

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>5，Redis持久化方式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RDB：按照一定时间堆内存的数据以快照形式保存在硬盘，产生dump.db文件，通过配置save参数定义快照时间周期。
优点：单文件方便持久化，性能最大化（主进程继续处理命令通过fork子进程完成持久化操作）。
缺点：持久化存在间隔，通过fork协助完成持久化任务，在大量数据情况下可能导致整个复制停止几百毫秒。

AOF:Redis将写操作记录在单独日志文件，重启Rdis执行这个文件，AOF可以配置每一行命令操作都记录在AOF文件。通过uppend写文件即使中途宕机也可用AOF工具解决数据一致性问题。RDB与AOF同时执行优先执行AOF。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。
缺点：文件更大，恢复满，如果每秒都写造成效率低。

如何选择持久化方式？
根据具体业务选择：可以承受部分数据丢失选择RDB。
达到Postger Sql数据安全？
RDB与AOF共同使用，重启时使用AOF恢复原始数据，定时生产RDB快照便于数据库备份与数据恢复

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>6，Redis持久化数据和缓存如何扩容？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>缓存扩容使用一致性哈希实现扩容缩容
持久化使用固定的keys-to-nodes映射关系，节点数量确定不能改变，否则必须在运行时进行数据平衡，目前只有Redis集群可以。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>7，过期键删除策略</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>定时过期：每个设置过期时间的Key都要创建一个定时器，时间一到立即清除。会占用大量CPU资源区间接影响像时间和吞吐量。
惰性删除：访问一个key时，才会判断是否过期。节省CPU，可能会出现缓存大量的过期Key。
定期删除：每隔一段时间执行一次删除过期键操作，通过限制删除操作执行的的时长和次数来减少对CPU的影响

如何选择？
惰性删除与定期删除。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>8，Redis内存淘汰策略有哪些？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Redis 提供 6 种数据淘汰策略（即，内存淘汰策略）
volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用 的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据
Redis内存淘汰策略选取并不会影响过期的Key处理，内存淘汰策略用于处理内存不足时需要申请额外空间数据，过期策略用于处理过期的缓存数据。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>9，Redis线程模型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>基于Reactor模式的网络时间处理器（文件时间处理器），四部分组成：多个套接字，多路复用程序，文件时间分派器，事件处理器。
文件处理器使用IO多路复用程序监听多个套接字，根据套接字目前执行任务关联事件处理器，当被监听的套接字准备好了执行链接应答，读取，写入，关闭等操作，对应的文件事件就会产生，这时文件处理就会调用套接字关联的事件处理器来处理事件。
文件事件处理器以单线程方式运行，通过使用IO多路复用程序监听多个套接字，文件事件处理器实现了高性能网路通信模型，又很好与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>10，Redis事务概念？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>事务本质：mulit，exec，watch命令组合，一致性，顺序性，排他性的执行一个队列中的一系列命令。
事务阶段： 事务开始：mulit  - 命令入队 - 事务执行：exec
Reids事务特点：不支持回滚，失败也继续执行。命令出错，命令都不执行。运行时出错，正确命令被执行。
相关命令：
watch：乐观锁，为redis提供check-and-set（CAS）行为，监控一个或多个键，一旦有键被修改则事务就执行，监控持续到exec。
discard：清空事务队列。
unwatch：取消watch对所有key监控。

Redis支持隔离性，支持原子性，但是事务不保证原子性且没有回滚。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>11，集群</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Redis集群模式：主从复制，主从复制+哨兵模式（高可用），redis3.0Cluster采用无中心结构，中间件代理（未使用过）
主从复制+哨兵集群：
将读写进行分离（主写从读），部署多台Redis在配置文件中指定Redis之间主从关系。主机为master节点slave节点用于读。建议以链表形式搭建，降低注解写压力。
原理：
初始化复制时节点启动后发送sync命令。主机使用RDB持久化并将快照命令期间命令缓存，完成后，节点收到RDB文件和缓存命令则进行加载。之后每次写操作都会同步给节点，保证数据一致性。
优点：读写分离，可以扩展读能力，采用主备架构，可以自动切换，持久化功能和合理配置策略，有效解决数据误操作和数据异常丢失问题。
缺点：哨兵选举期间禁止写操作，高并发时大量写请求同步主机压力极大，大量冗余数据存在。

去中心化集群：
数据分布原理：Redis 集群使用数据分片（sharding）来实现：Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数(集群使用公式 CRC16(key) % 16384)，这样每个key 都会对应一个编号在 0-16384 之间的哈希槽，那么redis就会把这个key 分配到对应范围的节点上了。同样，当连接三个节点任何一个节点想获取这个key时，也会这样的算法，然后内部跳转到存放这个key节点上获取数据。

高可用主从模式：
为了保证数据库的高可用加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉.

什么时候整个集群就不能用了？
如果集群任意一个主节点挂掉,且当前主节点没有从节点，则集群将无法继续，因为我们不再有办法为这个节点承担范围内的哈希槽提供服务。但是，如果这个主节点和所对应的从节点同时失败，则Redis Cluster无法继续运行。

添加或删除节点？
添加D节点到集群只需要将ABC某些Slot移动到节点就好。
删除A节点，集群只需要将A节点中所有slot移动到B，C节点，然后在移除空白的节点A。

什么是一致性哈希？
麻省理工体提出的分布式哈希实现算法，常用于负载均衡，解决将Key-Value均匀分配到多个server上的问题，取代传统取模操作，解决取模操作无法应对增删server的问题。（增删server会导致同一个key,在get操作时分配不到数据真正存储的server，命中率会急剧下降）

优点：动态扩容，具备sentinel箭扣和自动failover故障转移能力。客户端不需要链接所有节点链接一个即可。
：运维复杂，数据迁移需要人工干预，只可以使用0数据库，不支持批量操作，分布式逻辑和存储快耦合等。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>12，Redis集群会有写操作丢失？为什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Redis不保证强一致性，集群在特定条件下会丢失写操作

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>13，Redis集群之间如何复制？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>异步复制

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>14，Redis集群最大节个数？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>理论来说是16384

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>15，Redis集群如何选择数据库？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>集群值默认0不可改

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>16 ，分区</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Reids只有需要提高CPU利用率在考虑分区
因为分区让Redis管理更大内存，没有分区你最多使用一台机器的内存，分区使Redis计算能力和带宽通过的增加计算机就可以成倍增加。

分区方案：
客户端分区：客户端决定数据存储哪个Redis节点或哪个redis中读取。
代理分区：客户端将请求发送代理，然后代理依据分区规则决定去哪个节点写数据库拉数据。
路由分区：客户端随即请求一个redis实例，由Redis将请求转发给正确的redis节点，但并不是直接定位，而是借助客户端直接重定向到正确节点。

缺点：不能涉及多个Key操作（交集等），不可使用Redis事务。分区特别复杂比如扩容缩容都是。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>17，分布式问题</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>分布式锁：
利用Redis单进程单线程，采用队列模式将并发访问变为串行访问，使用setnx命令操作分布式锁。

Redis并发竞争key：就是多个系统对同一个Key操作，使用分布式锁解决。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>18，缓存问题</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>缓存雪崩：就是同一时间大面积缓存失效。
解决：设置缓存数据过期时间为随机，防止同一时间数据过期或添加缓存标记过期后更新缓存。

缓存穿透：数据库和缓存都没有的数据被一致访问。
解决：
	布隆过滤器
	数据库都没有的话在Redis设置以key-null形式存在设置短期过期时间防止大量请求。
	接口校验参数正确性。

缓存击穿：类似于热点key突然过期，大量请求到数据库。
解决：热点key不过期

热冷数据：热点数据才有缓存价值，比如导航信息，点赞，收藏都可以使用Redis避免频繁操作数据库

如何保证缓存与数据库双写时的数据一致性？
	建议：先更新数据库，在删除缓存。短时间数据不一致根据业务情况选择。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>19，性能优化</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，master最好不要做持久化工作，数据关键则在从库开启AOF备份，主从机通常在一个局域网内避免压力大的主机添加从机，主从结构以链表形式最为稳定。
2，一个字符串最大存储512M。
3，Reids如何做大量插入：2.6以后就开始了redis-cli支持一种pipe mode模式用于此场景
4，假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
 keys：速度会快但是造成线程阻塞一段时间
 scan：速度慢会有重复率但是不会阻塞

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="mybatis"><a href="#mybatis" class="header-anchor">#</a> Mybatis</h2> <p>1，JDBC有哪些不足，mybatis如何解决？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，数据库链接的创建，释放频繁浪费资源。
2，SQL写在代码不容易维护。
3，SQL语句传递参数麻烦，比如where条件不一定，可能多可能少。
4，结果集解析麻烦，将数据库表与POJO对象做关系映射。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>2，Mybatis编程步骤？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>创建SqlSessionFactory
通过SQLsessionFactory创建SQLsession
调用session.commit()提交事务
调用seesion.close()关闭会话

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>3，什么是Mybatis？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>一个半ORM框架，内部封装了JDBC，加载驱动，创建链接，创建statment等繁杂的过程，开发者只需要关注如何编写SQL，可以控制SQL，灵活度更高。
可以使用XML或注解来配置和映射原生信息，将POJO映射为数据行，避免几乎所有的JDBC代码，手动设置参数，手动获取结果集。
通过XML文件或注解方式将要执行的statement配置起来，并通过Java对象和statement中的sql动态参数进行映射生产最终执行的SQL语句，由mybaits框架执行sql并将结果映射为Java对象并返回。
专注于SQL本身，灵活度更搞，适合对性能要求较高的项目。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>4，优缺点？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>优点：
基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成影响。
SQL在XML文件中，与程序代码完成解耦合，支持动态SQL，可重用。
JDBC相比减少一半以上代码量，不需要手动开关链接。
提供映射标签，支持对象与数据库的ORM字段关系映射，很好的与Spring集成。
缺点：
SQL编写工作量大，需要开发者对SQL有一定功底。
SQL语句依赖于数据库，导致数据库移植性差。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>5，${}和#{}区别是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>${}：是字符串替换，无法防止sql注入。
#{}:是预处理，将#{}转为？调用PreparedStatement的set赋值，防止SQL注入。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>6，mapper.xml文件，都会对应一个DAO接口，这个DAO接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Mapper的工作原理是JDK动态代理，为Mapper接口生产代理对象proxy，代理对象拦截接口方法，根据全限定类名+方法名定位到mapperStatment并调用执行器执行SQL,然后将SQL结果返回。

接口方法不能重载。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>7，Mybait使得Xml映射文件中，不同的XML映射文件ID是否可以重复？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>不同的映射文件 namespace配置了就可以重复。否者不可以。
原理：因为namespace+id作为map的key。
新版本中namespace必须声明。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>8，mybaits如何进行分页？分页插件原理？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>使用RowBounds对象进行分页，它针对ResultSet结果集执行内存分页非物理内存。可以在sql使用分页参数来完成分页，也可以使用分页插件。
分页插件就是利用mybaits提供的接口，实现自定义插件，在插件方法内拦截待执行的SQL，然后重写SQL，根据方言添加物理分页语句和物理分页参数。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>9，mybaits的插件运行原理，如何编写一个插件？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>mybaits只可以编写paramenthandler，ResultSetHandler，StatmenHandler，Executor这四种接口插件，使用JDK动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

实现mybait使得interceptor接口复写intercept方法，然后给插件编写注解，指定要拦截哪个接口方法即可，在配置文件配置你的插件。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>10，mybaits是否支持延迟加载？原理是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>支持association关联对象和colleaction关联集合对象的延迟加载。lazyLoadomgEnbled=true|false

原理：使用CGLIB，创建目标对象的代理对象，当调用目标方法时，进入拦截方法。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>11，Mybait使得一级缓存？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>一级缓存：基于PerpetualCache的hashMap本地缓存，其存储作用域为session，当session flush或clone后，该session中的所有Cache情况，默认打开一级缓存。
二级缓存与一级缓存机制相同，默认采用PerpetualCache，HashMap存储，不同在于其存储作用域为Mapper，并且可以自定义存储源。默认不打开二级缓存，使用二级缓存需要实现序列化接口。
对于缓存数据更新机制：当某个一级或二级进行了C/u/d操作后，默认该作用与下的所有select中的缓存被清空调用，如果开启二级缓存，则只根据配置判断是否刷新。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>12，Mybaits是如何将SQL执行结果封装为目标对象并返回？有哪些形式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>使用标签，逐一定义数据库列名和对象属性名之间的映射。
使用sql列的别名功能，将列的别名写为对象属性名

有了映射关系后，Mybaits通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>13，动态SQL有什么用？执行原理？有哪些动态SQL？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>可以使用逻辑判断来完成拼接SQL的功能。
trim where set foreach if choose when

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>12，Xml映射文件中，除了常见的select|insert|updae|delete标签外，还有哪些标签？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;sql&gt; &lt;resultMap&gt; &lt;include&gt; &lt;SelectKey&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>13，mybaits的mapper接口调用有哪些要求？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>接口方法名与XML定义的ID相同。
接口输入参数类型和xml定义的paramenterType类型相同
输出参数类型与xml定义的resultType一直
xml文件namespace是mapper接口的类路径。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>14， 模糊查询like语句该怎么写?</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>调用拼接函数，contains（）

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>15，实体类属性名和表中字段不一致怎么办？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ResultMap映射，as别名

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>16，如何获取自动生产的主键？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>nsert 方法执行完后可以被设置到传入的参数对象中。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>17，在mapper中如何传递多个参数?</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@param
封装为对象
封装为map

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>18，什么是mybaits的接口绑定？有哪些实现方式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>接口绑定，就是任意定义接口与SQL绑定，这样调用接口就可以了。
注解绑定，@Select @Delete等注解
xml文件中namespace为全限定接口名。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>19，Mybaits和Hibernate有哪些不同？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>一个半ORM框架，一个是ORM框架。
mybaits更加的灵活，可以严格控制sql性能。
Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="spring"><a href="#spring" class="header-anchor">#</a> Spring</h2> <p>1，Spring有哪些模块？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>context：提供Bean访问方式等
core：提供核心类库
AOP：aop服务
MVC:提供面向web应用的Model-View-Controller，MVC实现
DAO：对JDBC抽象封装，简化数据访问异常处理。
ORM：现有的ORM框架支持

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>2，什么是Spirng？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>降低企业级应用开发的复杂性，提供两大核心功能IOC与AOP。采取了四个关键词了POJO轻量级和低入侵式编程，依赖注入和面向接口实现松耦合，切面和惯例的声明是编程，切面和模板介绍样板是代码。

优点：简化开发，解耦合，AOP，声明事务，方便集成优秀框架
缺点：依赖反射

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>3，使用到的设计模式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>单例：beanfactory
工厂：Bean单例模式
观察者：定义一对多的依赖关系，一个对象状态改变其他依赖她的对象会被动更新
模板：解决重复代码，RedisTemplate等
代理：AOP

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>4，说下核心容器Spring context模块？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>提供Spring框架基础功能，BeanFactory是Spring基础的核心，他让Spring称为一个容器。是工厂模式的实现，提供控制反转功能，将应用配置和依赖分离出来。常用的是XMLBeanFactory对象，从XM类文件加载Beans，读取元数据并创建Bean。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>5，类型的事件？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。
上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。
上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。
上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。
请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>6，什么是IOC？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>就是将由程序代码操控的对象管理权交给容器，通过容器实现组件的装配和管理。由IOC负责创建，管理，装配，配置对象并管理整个声明周期。
IOC主要作用是管理对象之间的依赖管理，解耦合，托管类的生产过程，可以将代码量降到最低，最小代价实现松散耦合，IOC容器加载支持懒加载和饿汉式加载。
IOC底层通过工厂加反射实现，支持依赖注入，依赖检查，自动装配，支持集合，指定init和doty方法
IOC的实现方式为DI与DL
DI：更加贴合IOC的思想，被动的接收注入，不依赖于容器的API，可以脱离容器
DL：已经被废弃，组件主动的查询其依赖的组件，过于依赖容器Api,很难脱离容器。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>7，BeanFactory和ApplicationContext</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>BeanFactory和ApplicationContext之间的区别。？
BeanFactory和ApplicationContext是Spring两大核心接口都可以当作容器。Application是BeanFacotry的子接口。

BeanFactory最底层接口，低级容器，提供对Bean，读取Bean配置文档，管理bean的加载，实例化，维护声明周期，维护bean之间依赖关系。采用延迟加载模式，BeanFactory通常以编程的方式被创建。
BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。

AplicationContext，依赖（不是继承）于BeanFacotry容器，具备BeanFactory所具有的功能外，还支持国际化，统一资源访问方式，提供在监听器中注册bean事件，加载多个配置文件，载入多个（有继承关系）的上下文，采用饿汉式加载bean，ApplicationContext通常以声明的方式创建。
BeanFactory已经不是工厂而是应用上下文，代表整个大容器的所有功能，该接口定义了refresh方法用于刷新整个容器。实现类：FileSystemXmlApplicationContext ，ClassPathXmlApplicationContext，WebXmlApplicationContext

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>8，Bean的声明周期？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>（1）实例化Bean：
对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。
对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。
（2）设置对象属性（依赖注入）：实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成属性设置与依赖注入。
（3）处理Aware接口：Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的一些资源：
①如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，传入Bean的名字；
②如果这个Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。
②如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。
③如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；
（4）BeanPostProcessor前置处理：如果想对Bean进行一些自定义的前置处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。
（5）InitializingBean：如果Bean实现了InitializingBean接口，执行afeterPropertiesSet()方法。
（6）init-method：如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。
（7）BeanPostProcessor后置处理：如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；
以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。
（8）DisposableBean：当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；
（9）destroy-method：最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>9，什么是Spring的依赖注入？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>主要就是DI依赖注入和DL依赖查找；
依赖注入：组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。

依赖注入基本原则：
组件不负责查找资源，配置对象工作由IOC容器完成，它会将符合依赖关系的对象通过set或构造器传递给需要对象

依赖注入方式：
setter：无参构造或无参静态工厂实例化bean后，调用bean的stter方法实现。
可以有部分注入，会覆盖stter方法，修改不会创建实例。
构造器 ：触发类构造器实现，类的每个参数都代表对其他类的依赖。
没有部分注入，不会覆盖stter属性，任意修改都会创建一个实例。
接口（spring4废弃）

依赖注入优势：
查询定位与应用代码无关，不依赖于容器API，可以在任何容器外使用应用对象，不用特殊接口，绝大数对象可以做到完全不依赖容器。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>10，什么是SpringBeans？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>形成spring应用的主干对象，被IOC初始化，管理。通过容器中配置的元数据创建。比如XML定义

springBean定义包含什么？
容器必知的元数据，包括如何创建一个Bean，声明周期详情以及他的依赖关系。

如何配置元数据？
XML 注解 java配置

注入的bean的几种方式？
构造器 set() 静态工厂 实例工厂

bean的作用域？有哪几种？
通过bean的Scope属性定义。
singleton：单例bean
prototype：一个bean对应多个实例
request：一个request请求对应一个实例
session：一个Http seesion请求对应一个实例
global-session：一个全局的http session下一个请求对应一个实例，尽在Web的Spring applicationcontext下有效

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>11，单例Bean线程安全么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>不是安全的。
无状态是安全的有状态（有数据存储功能）是不安全的需要手动保证安全。
使用prototype，这样都是新的bean。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>12，Spring如何处理线程并发？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，可以使用锁机制保证同步机制，但是需要考虑什么时候对变量读写，什么时候需要锁定对象等复杂问题。
2，ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。
同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>13，哪些是重要的bean生命周期方法？ 你能重载它们吗？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>setup 容器加载bean调用和teardown容器卸载类的时候调用
@PostConstruct和@PreDestroy

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>14，什么是内部bean？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>一个bean仅被另一个bean用作属性时，就是内部bean。通常是匿名的，作用域为prototype。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>15，bean装配</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>bean装配：容器通过依赖关系将bean组装到一起。
bean自动装配：配置文件设定好的bean依赖关系，容器可以自动装配相互合作的bean。
自动装配有哪些？
no：不进行自动装配，通过手工设置ref属性来进行
byName：通过名称自动装配
byType：通过类型自动装配
constructor：利用构造器，单参数通过byType
autodetect：如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>16，注解</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>如何开启自动装配？
配置文件中使用 &lt;context:annotation-config/&gt;
@Required：bean属性必须在配置时候设置，否则会抛出异常
@Autowired：按照类型装配注入，可以通过required属性设置依赖对象是否必须存在。
@Resource：默认按照name装配，匹配不到使用类型装配。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>17，如何更加有效使用JDBC？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>借助Spring jdbc框架，资源管理和错误处理代价被降低，开发者只需要关注statements和queries从数据存取数据，JDBC也可也在模板类的帮助加更加有效使用。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>18，spring DAO 有什么用？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>19，JdbcTemplate是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>20，Spring支持的事务管理类型， spring 事务实现方式有哪些？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>声明式事务，编程时事务。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>21，Spring事务的实现方式和实现原理？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Spring本质还是对数据库的事务支持，所以spring无法提供食物，真正数据库层的事务提交和回滚是通过，binlog和redo log实现。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>22，说一下 spring 的事务隔离？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>default：数据库的隔离级别
uncommitted：读未提交，会出现幻 脏 不可重复
read committed：读提交，事务提交后才能被其他事读取，幻读 不可重复读
repeatable read：可重复读，会幻读。
serializable：序列化，代价最高，最可靠的隔离级别。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>23，Spring框架的事务管理有哪些优点？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>不同事物提供不变的编程模式
编程式事务提供一套简单的API
声明式事务
和Spring数据访问抽象层很好集成

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>24，什么是AOP？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>作为面向对象的一种补充，将与业务无关但对多个影响公共行为和逻辑抽取并封装为一个可重用的模块（切面），减少重复代码。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>25，Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>代理模式分为：AOP是动态代理 AspectJ是静态代理
静态代理称之为编译时增强，在编译阶段将切面植入Java字节码文件，运行后就是增强后的AOP对象。
动态代理
动态代理会在运行时为内存中临时方法生产一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的别面做了增强处理并回调原来方法。
JDK动态代理和CGLIB动态代理的区别
JDK动态代理：只支持接口代理，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。
CGLIB动态代理：是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>26，AOP中的名词？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>切面：切点和通知节结合，定义了切面全部内容。
连接点：在应用执行过程中的一个点，切面代码利用这些点插入正常流程中，添加新的行为。
通知：切面的工作
切入点：匹配通知所织入的一个或多个连接点。
引入：允许我们向现有类添加新方法或属性。
目标对象：切面所通知的对象
织入：织入是把切面应用到目标对象并创建新的代理对象的过程。
编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。
类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。
运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>27，Spring在运行时通知对象？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>通过代理类包裹切面，Spring在运行期间把切面织入到spring管理的bean中，拦截被通知方法的调用，再将调用转发到真正目标bean，在代理拦截到方法调用时，调用目标beanf之前执行切面，直到应用需要代理bean时候spring才会创建bena。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>28，关注点和横切关注的区别是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>关注点是一个模块的行为，一个关注点可能被定义成一个想要实现的功能。
横切关注点也是个关注点，是整个应用都会用的功能，比如日志，安全数据传输等等。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>29，通知的类型？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>前置通知（Before）：在目标方法被调用之前调用通知功能；
后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；
返回通知（After-returning ）：在目标方法成功执行之后调用通知；
异常通知（After-throwing）：在目标方法抛出异常后调用通知；
环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>30，spring循环依赖</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>什么是循环依赖？
就是A依赖B而B也依赖着A。
什么情况下循环依赖可以被处理？
前提条件：
1，循环依赖的bean必须是单例
2，依赖注入的方式不能全是构造器注入的方式
可解决：AB均采用stter方法注入，A注入B使用stterB注入A使用构造器

知识点：
一级缓存中存储的是已经完全创建好了的单例Bean
二级缓存

如何解决循环依赖：
Spring正是通过singleton单例bean的setter方式解决循环依赖的，ClassA在创建的时候，会将自己放入到singletonObjectFactories三级缓存中，在属性装配的时候，检测到ClassA对象依赖于ClassB对象，Spring首先尝试从容器中获取ClassB，此时ClassB不存在，Spring容器会初始化ClassB，同时也将ClassB暴露到容器中，接着就是对ClassB进行属性装配，Spring从容器中获取ClassA，因为之前已经将ClassA暴露到容器中了，因此可以获取到ClassA实例，并将ClassA升级放入二级缓存earlySingletonObjects中，ClassA通过给Spring容器获取到ClassB，完成了ClassB的初始化操作，这样ClassA和ClassB都完成了对象初始化操作，便解决了循环依赖问题。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="springboot"><a href="#springboot" class="header-anchor">#</a> SpringBoot</h2> <p>1，什么是SpringBoot？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>简化spring开发难度，省去了繁重的配置，提供启动器实现快速开发。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2，SpringBoot优点？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>容易上手，提高开发速度
开箱即用，远离繁琐的配置。
提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。
没有代码生成，也不需要XML配置。
避免大量的 Maven 导入和各种版本冲突。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>3，Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@SpringBootApplication
由三个注解组成：
@EnableAutoConfiguration：实现配置文件功能
@SpringBootConfiguration：打开了自动配置功能，也可以关闭某个自动配置选项。
@ComponentScan：注解扫描，默认为此目录子目录

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>3，什么是 JavaConfig？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>提供了ioc容器纯Java方法，避免使用XML配置。
1，面向对象配置，充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。
2，减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。JavaConfig提供一种纯Java方法来配置。
3，类型安全和重构友好，因为JDK5对泛型的支持

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>3，Spring Boot 自动配置原理是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@SpringBootApplication注解是组合注解，其中由个@Import注解，导入了AutoConfigurationImportSelector类，selectImports（）方法涵盖了组件自动配置所有处理逻辑（配置类，配置类去重，排除不要的配置类，过滤等）。最终返回符合条件的自动配置类的全限定名数组。
然后getCandidateConfigurations()方法通过SpringFactoriesLoader加载器加载META-INF/spring.factories文件，首先通过这个文件获取到每个配置类的url，再通过这些url将它们封装成Properties对象，最后解析内容存于Map&lt;String,List&lt;String&gt;&gt;中

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>4， Spring Boot 配置加载顺序？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1）properties文件；

2）YAML文件；

3）系统环境变量；

4）命令行参数；

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>5，什么是 YAML？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>可读的数据序列化语言，更加结构化。优势：配置有序，支持数组，简洁

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>6，Spring Boot 是否可以使用 XML 配置 ?</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>通过 @ImportResource 注解

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>7，spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载。（配置中心）
application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>8，CSRF攻击？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。
验证 HTTP Referer 字段
在请求地址中添加 token 并验证
在 HTTP 头中自定义属性并验证

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>9，监视器是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Spring boot actuator可以帮助访问生产环境正在运行的应用程序，检查和监控服务的状况。adminServer就是建立再次之上。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>10，运行SpringBoot有哪几种方式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1）打包用命令或者放到容器中运行
2）用 Maven/ Gradle 插件运行
3）直接执行 main 方法运行

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>11，Spring Boot 有哪几种读取配置的方式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@PropertySource,@Value,@Environment, @ConfigurationProperties

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>12，SpringBoot 实现热部署有哪几种方式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Spring Loaded
Spring-boot-devtools

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>13，如何定义多套不同配置环境？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>application-dev.properties
application-test.properties
application-prod.properties

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>14，SpringBoot有哪些特性？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>起步依赖和自动装配
起步依赖：在起步依赖上，spring boot帮我们管理了各个依赖的版本，使各个依赖不会出现版本冲突；另外，帮我们打包了各个依赖让我们不用再像之前那样自己导入一大堆的依赖，只要引入起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的用。
自动装配：是spring boot的一大特性，新建spring boot项目之后，会发现在启动类上有个@SpringBootApplication注解，而springboot也是通过该注解去自动装配的。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>15，Spring Boot与Spring cloud的区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>boot是快速配置的脚手架快速开发单个微服务，cloud基于boot实现的云应用开发工具。
boot专注快速，方便集成个体，cloud是关注全局的服务治理框架
boot约定大于配置理念，cloud基于boot实现。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="springmvc"><a href="#springmvc" class="header-anchor">#</a> SpringMVC</h3> <p>1，什么是Spring MVC？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>SpringMVC是基于Java的MVC设计模式的请求驱动的轻量级的web框架，通过model-view-controller职责解耦，将复杂的web程序分为逻辑清晰的几个部分。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2，Spring MVC流程？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>用户发出的请求到前端控制器接，调用处理映射器，处理映射器根据url匹配具体的handelr生成对象处理器对象和处理拦截器返回给前端控制器，前端控制将气调用处理适配器处理器执行handler，处理适配器调用handler获取执行后的modelandview返回给前端控制器，前端控制器调用视图解析器，解析完毕后返回view给前端控制器，前端控制器渲染view后响应。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>3，springMVC的优点？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>支持各种视图解析技术
天然与spring集成
清晰角色分配
支持各种资源请求策略

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>4，重定向与转发？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>forword：
rediect：

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>5，Springmvc常用注解？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@RequestMapping：设置方法或类的请求资源地址。（类上：类所有响应请求方法的方法都是以该地址作为父路径）
@RequestBody：将JSON对象转为Java对象。
@ResponseBody：注解实现将controller方法返回对象转为JSON对象。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>6，如何解决POST请求中文乱码问题，GET的又如何处理呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>web.xml文件中添加CharacterEncodingFilter过滤器

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>7，SpringMVC拦截器是怎么写的？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>实现handlerInterCeptor接口三个方法
拦截器：在前端控制器将请求发送controller之间拦截器执行。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>8，SpringMVC的异常处理？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>可以将异常抛给Spring框架，由Spring框架处理，配置一个异常处理器，添加试图页面即可，但是403不是异常。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>9，SpringMVC 控制器是不是单例模式？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>是单例模式，多线程访问存在线程安全问题，解决方案在控制器里面不写可变的状态量。否则采用ThreadLocal机制解决。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>10，如何设置这个方法只拦截get请求？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@RequestMaping注解加上method=RequestMethod.GET

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>11，如何方法中得到rquest？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>直接在形参声明Request对象。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>RabbitMQ</p> <p>1，为什么使用MQ？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>什么RabbitMq？
rabbitmq实现了高级消息队列协议（AMQP)的开源消息代理软件，使用Erlang语言编写。
什么是消息队列？
就是通过队列来通信的组件
特点？
消息可靠性，灵活的路由，扩展性（集群），靠可用（镜像），多种协议（stomp，mqtt），管理页面。
AMQP是什么?
就是RabbitMQ当中的交换机，交换机类型，绑定，队列，路由键都是遵循AMQP协议的。
AMQP协议的三层？
Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。
Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。
TransportLayer:最底层，主要传输二进制数据流。

异步处理：异步处理提高系统吞吐量
应用解耦：生产者和消费者无需关心对方。
流量削峰：通过消息队列让并发转为串行化，缓解短时间高并发请求。
日志处理：解决大量的日志传输。
消息通讯：内置高效通信机制，也可以用在纯消息通信。比如实现点对点消息队列或聊天室。

详解：解耦，晓峰，异步
解耦：A系统无需关注向哪些系统发送服务，只需要将消息放入队列，需要这个消息的系统去订阅这个消息队列即可。这样系统与系统之间的关联度很低。
削峰：通过消息队列可以减少高并发下的服务器压力，生产者只需要向队列发送一个消息即可，而消费者可以根据自己处理请求的能力进行处理。
异步：异步可以提高响应速度，比如主线程只要完成主要任务和重要任务，而其他的任务扔进消息队列让消费者慢慢处理即可。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>2，使用消息队列的问题？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>系统可用性降低：如今服务要保证靠可用的前提下，使用rabbitmq无疑降低了高可用，因为A系统和B系统的通信借助的是RabbitMq，所以MQ一旦宕机，AB系统就都无法使用。所以也要保证Rabbitmq的高可用。
一致性问题：比如A系统消息队列发了写库信息后直接返回了成功，但是消费方发生异常写库失败，造成数据库不一致。
系统复杂度提高：加入队列后考虑的问题很多：一致性问题，重复消费，投递问题，传输的可靠性，消息丢失问题。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>3，如何选用消息中间件？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>市面上ActiveMq，RocketMQ，RabbitMQ，Kafka
ActiveMQ:apache下的子项目，未用过。
RabbitMQ：适合中小型企业，支持高并发高吞吐性能很高，还支持集群化，高可用部署结构，消息可靠性，功能比较完善。
RocketMq:阿里开源，超高并发，高吞吐，性能高，支持分布式事务的特殊场景。但是还是不够成熟。
Kafka：可以用于超高的吞吐量的实时日志采集，实时数据库同步，实时数据计算等，在大数据领域用的很多。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>4，如何确保消息正确地发送至<a href="https://so.csdn.net/so/search?q=RabbitMQ&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">RabbitMQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>发送确认模式，确保消息发送到rabbitMq。
将信道设置为confirm模式，所有信道上发布的消息都会被指派一个唯一ID，一旦消息被投递到目标队列后或写入磁盘后（可持久化消息），信道返回一个确认给生产者（包含唯一ID）。

如果消息发生内部错误消息丢失，发送一条nack（not acknowledged，未确认）消息。
发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息，当确认消息到达生产者时，会触发回调方法处理确认消息。
消息丢失返回的消息会有消息丢失的方法回调。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>5，如何确保消息接收方消费了消息？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>接收方确认消息：接收每接收一条消息后必须进行消息确认。消费者确认了消息，RabbitMQ才能安全的把消息从队列中删除，不用超时机制的情况下，Mq仅通过消费者是否中断连接来确认是否需要重新发送消息，如果不中断，会给消费者足够长的时间消费。
特殊情况：
如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）
bizID：同一业务的全局唯一，作为去重和幂等的依据。
如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>6，如何避免消息重复投递或重复消费？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为消息唯一主键，作为去重和幂等的依据。
避免重复的消息进入队列。
消息消费时，要求消息体中必须要由一个个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。

业务场景：
1，如果这个消息是insert操作，给这个消息做唯一主键，就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。
2，如果是redis的set操作，那么不需要解决，无论set几次结果都是一样，set操作本来就是幂等性操作。
3，如果其他场景，借助第三方介质做消费记录，将消息id记录在redis，只要消费过消息记录在redis没有则可以消费。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>7，如何解决消息丢失问题？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>生产者：
生产者消息投递到MQ的过程中丢失怎么办？RabbitMQ采用transaction和confirm模式来确保生产者消息不丢失。
transaction同步：就是就是txSelect开启事务，txRallback回滚，txCommit提交。
confirm异步:上面提及过了

消息队列：
消息在消息队列丢失数据的情况，一般是开启持久化磁盘的配置，这个持久化配置配合confirm机制使用发，消息持久化磁盘后，再给生产者发送ack信号。

消费者：
启动手动确认模式解决问题：
1，自动确认模式：不在乎消费者对消息处理是否成功，都会告诉队列删除消息。如果处理消息失败，实现自动补偿（队列投递过去 重新处理）。

2，手动确认： 消费者处理完业务逻辑，手动返回ack（通知）告诉队列处理完了，队列进而删除消息。
消费者出现异常则会触发异常重试机制：
1，如果网络通信原因异常，此时需要重试机制。
2，如果因为程序问题异常，（数据转换，空指针等等）则需要计入日志然后进行人补偿。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>8，如何持久化？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，声明队列（queueDeclare）时开启持久化。 durable=true
2，basicPublish方法第三个参数为MessageProperties.Persistent_text_plain
注意：
将消息标记为持久化并不能完全保证消息丢失，尽管RabbitMQ消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘时的一个间隔点，此时并没用将持久化完成。但是对于简单已经足够使用。也可以使用发布确认来确保

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>9，RabbitMq六大工作模式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，简单模式：简单的收发模式
	生产者生产消息放入队列。
	消费者监听消息队列，如果有消息就消费调用，消息被拿走后自动从队列中删除。
	问题：消息可能没有被消费者正确处理就消失了；
	设置为手动确认模式，处理完毕后发送ack到消息队列，未及时发送ack会导致消息队列内存益出。
2，工作模式：资源的竞争
	将消息放入队列后消费者可以由多个，同时监听一个队列消费消息。c1 c2共同争抢当前的队列内容谁先拿到谁负责的消费消息，
	问题：高并发下可能一个消息被多个消费者共同消费。
	可以设置开关syncronize保证一条消息只能被一个消费者使用。
3，发布订阅模式：共享资源。
	生产者将消息发送给Broker，有交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都会接收到	消息。
4，路由模式
	 根据队列绑定在交换机的routing key，这样交换机就可以根据routing key的消息发到不同的队列中，然后消费者消费不同的队列中的消息。
5，主题模式：
	在路由模式更加丰富，在路由模式的基础上可以使用通配符，*代表匹配多个单词，#代表匹配一个单词。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>10，RabbitMq组成部分：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Broker：接收客户端的链接，实现AMQP实体服务。
connection：链接，应用程序与Broker的网络链接TCP/IP,三次握手四次挥手
channel：网络信道，所有的操作都在Channel中进行，channel是进行消息读写的通道，客户可以建立对各Channel，每个channel代表一个会话任务。
message：服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。
Virtual Host：虚拟地址，进行逻辑隔离，最上层的消息路由，一个虚拟主机可以由多个exhange和queue。
Exchange：交换机，接收消息，根据routingkey发送消息到绑定队列。
bindings：交换机与队列虚拟链接，binding中可以保护多个routing key。
routing key：路由规则虚拟机可以用它来确定路由一个特定消息。
queue：队列，称为message queue消息队列，保存消息将他们转发给消费者。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>11，不公平分发？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>多个消费者消费一个队列中消息采用轮询策略，当有消费者性能好时候效率很差。
不公平分发：消息一旦处理完就可以接收下条消息。
预取值：分发基础上提前固定每个消费者的固定消息数量，不受消费者执行影响。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>12，交换机的类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>fanout：把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。
direct：把路由消息到bindingkey和routingkey完全匹配的队列中
topic：通配符路由模式
headers：不依赖路由键匹配规则，根据消息内容中的headers进行匹配。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>13，集群模式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>普通集群：就是不同机器启动多个实例，这样可以提高吞吐量，并没实现高可用。
镜像集群：创建的queue无论元数据还是queue里的消息都会存在多个实例上，每个节点都由这个queue的完整镜像，每次写queue都会同步到多个实例的queue中。
缺点：性能开销很高，消息需要同步所有机器，导致网路带宽压力和消耗很重，扩展性极低，数据冗余，且queue数据量大的情况下就算增加机器哪个机器也包含queue的所有数据，queue数据并没有做到分布式存储。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="security"><a href="#security" class="header-anchor">#</a> Security</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>Security构建在一系列的Filter，这些Filter会拦截请求，检测身份信息并将其重定向到身份认证组件或者授权组件。 我常用的是UsernamePasswordAuthenticationFilter + AuthenticManager + 真正调用提供者Provider。

Security主要做认证和授权两部分工作
认证：
1，请求会被usernamePasswordAuthenticationFilter拦截，不知道密码是否正确，所以构造一个未认证的token。
2，然后将token交给AuthenticationManager（认证管理器），进行认证
3，认证管理器委托authenticationProvder进行认证，调用userDetailsService查询数据并且token与查询出来的密码进行比较
4，认证成功后封装Autentication并设置好用户信息返回usernampasswordAuthenticationFilte。
5，调用工具将authentication放入securityContext存储起来，接着调用认证成功处理器0后续操作。
6，用户信息最后被保存在SecurityContext中，而SecurityContext利用ThreadLocal机制存储，默认。

鉴权时，首先得到对应的URL信息，然后调用decisionMannager来进行鉴权，现在框架有URL需要的角色信息，有框架缓存的认证信息，该认证信息有该角色信息，只需要对比后，如果认证信息的角色在需要的角色里面则权限透过，否则权限验证失败，调用AccessDeniedHandler处理。

Security主要用于权限设计，对用于进行 认证，对url授权。基于过滤器的，SecurityFilterChain默认有十几个顾虑器，可以在webSecurityConfig配置文件中添加自己的过滤器到过滤器链中实现自己需要的功能。

在Security中所有请求都会经过webSecurityConfiguration生成的bean但真正起着作用的一个FilterChain，每个FilterChain中的Filter有自己的职责，但是他们并不是直接处理用户认证和授权，而是交给AuthenticationManager和AccessDecisionManager进行管理。
AuthenticationManager主要做认证工作，ProviderManager为实现类，内部维护里AuthenticationProvider列表做认证工作。认证成功则继续失败则抛出异常。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>1，认证Authentication和授权Authorization的区别是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>authentication用于认证用户密码，身份的凭据
authoization：用于授权，资源授权。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>2，什么是Cookie？作用是什么？如何在服务端使用cookie？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>cookie和session都是用来跟踪浏览器的用户身份的会话方式，但两者应用场景不一致。
cookie保存登陆过的用户信息，下次访问网站页面可以帮你自动帮你将登陆的信息填了。
cookie保存了session和token，像后端发送请求的时候带上cookie，这样后端就可以以获取到session和token。可以记录用户当前状态，http是无状态的

使用cookie？
创建Cookie对象设置过期时间，放入response中
获取request后getCookies

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>3，Cookie 和 Session 有什么区别？如何使用Session进行身份验证？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Session主要就是通过服务端记录用户的状态信息，比如未登录状态下的购物车。
cookie数据保存在客户端，session数据保存服务端，session安全性更高。敏感信息加密存入到服务端解密即可。

Cookie和Session的区别：
cookie数据存放在客户的浏览器上，session数据放在服务器上。
单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
cookie不是很安全，别人获取到你本地的cookie。

很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。

依赖Session的关键业务一定要确保客户端开启了Cookie。
注意Session的过期时间

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>4，如果没有Cookie的话Session还能用吗？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>一般通过cookie保存sessionid，此场景下cookie别关闭后无法正常工作。
但如果不将Sessionid放入cookie也就没有影响，比如放在浏览器缓存，url地址后等。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>5，Token是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>是令牌，数据传输之前要先进行暗号的核对。使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。

流程：
	1，客户端使用用户名和密码进行请求登录
	2，服务端收到请求后，去验证账户名密码
	3，成功后服务器向客户端颁发token
	4，客户端将token保存起来，比如cookie，浏览器本地缓存。
	5，客户端每次访问都需要携带token
	6，服务端收到请求，然后验证客户端请求携带的tokne。

Token的优点：
1，相比于session，无需保存服务端，不占服务端内存。
2，分布式下的sesion不可用但是在token可以放在redis，进行验证。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>6，token与jwt区别</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1.普通令牌的作用：唯一标识存贮在数据库或内存中的用户信息，在认证时，SpringSecurity拿着普通令牌去redis中查询用户信息使用
2.jwt令牌的作用：jwt令牌中本身存储着用户信息，在认证时，SpringSecurity从jwt令牌中解析出用户信息即可，不需要借助数据库等进行存储

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>7，JWT组成</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>JWT由header，负载，签名。

header：类型和加密算法
载荷：携带存放的数据用户信息等数据
签名：自定义签名，防止伪造。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>8，为什么session无法防止CSRF，而Token可以？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>因为sesisonid会在登录成功后每次请求都会携带。
token是因为前端添加对拦截器在拦截器中加入这个token，所以非法链接是不会携带这个token的。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>9，什么是oauth2.0？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>OAuth行业的标准授权协议，主要用来授权第三方获取有限的权限，也就是授权机制，最终目的就是未第三方应用颁发一个有效性的令牌token，使得第三方应用能够通过该令牌资源。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="微服务"><a href="#微服务" class="header-anchor">#</a> 微服务</h3> <p>1，什么是微服务？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>微服务架构是一种架构模式，将单一的应用划分一组小的服务，每个服务都可以独立运行，服务之间相互协调，相互配合。 服务之间采用轻量级的通信机制互相沟通（通常是居于HTTP的RESTfu)。
每个服务都围绕具体业务进行构建，并且能独立部署。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>2，微服务有哪些优势？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>独立开发：每个服务都可以根据各自的功能轻松开发
独立部署：基于其服务，可以在任何应用程序中单独部署他们
故障隔离：即使应用程序的一项服务宕机，程序仍可运行
混合技术堆栈：使用不同编程源的优势构建。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>3，微服务的特点？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>解耦：系统内服务很大程序是分离的，因此整个应用可以轻松构建
组件化：微服务被视为可以轻松更换和升级的独立组件
业务单一：专注于单一功能
持续交付：允许频繁发布软件
分散治理：使用正确的工具来做正确的工作
敏捷开发：微服务支持敏捷开发，可以快速开发和丢弃

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>4，微服务缺点：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，增加故障排查
2，远程呼叫延迟
3，增加配置和其他操作的工作量
4，难以保持交易安全
5，艰难的跨域各种边界跟踪数据

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>5，springcloud与dubbo有哪些区别？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>都可以实现RPC远程调用框架，实现服务治理。
Springcloud是一套目前很全的微服务框架，整合了分布式常用的解决访问，注册中心，负载均衡，远程调用，分布式配置中心，服务保护，网关，服务链路，消息总线。
dubbo内部实现功能，只是实现服务治理，缺少网关链路总线配置中心。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>6，什么是注册中心？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>注册中心可以说是微服务架构中的“通讯录”，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。

为什么需要注册中心
服务启动后，如何被及时发现
服务宕机后，如何及时下线
服务如何有效的水平扩展
服务发现时，如何进行路由
服务异常时，如何进行降级

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>7，CAP？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>C：一致性（consistency）：所有节点在同一时间具有相同的数据。
A：可用性（Availability）：保证每个请求不管成功或者失败都有响应。
P：分区容错性（Parition tolerance）：系统中任意信息的丢失或失败不会影响系统的继续运作。

舍弃P:意味着你的系统不是分布式的，因为升级分布式的项目将机器分开不是在不同机器。
舍弃A:允许有段时间会出现访失效问题。
舍弃C：你的数据并发访问时数据不一致。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>8，Nacos源码总结</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1，使用异步的任务队列来执行一些可以牺牲一些时效性的任务，且在服务注册中注册与读取注册相分离，同时为了防止高并发带来的问题，大量使用CopyOnWrite的操作与底层注册实例存储为ConcurrentHashMap集合，提高在高并发下的性能，但是在内存中的操作，也会即使牺牲一点也会速度非常快。
2，相比于Eureka，Eureka采用多级缓存结构，只读缓存，读写缓存，内存注册表，各级缓存之间的定时同步，客户端感知的及时性不如nacos。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>9，什么是Nacos？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Nacos支持动态服务发现，配置管理，动态刷新，可用区AZ，分组，元数据，权重，健康检查，负载均衡，高可用集群部署多个功能，提供UI管理界面。
Nacos更像Eureka，Config，Bus，MQ的结合体脱胎于阿里内部的configServer。
nacos支持cp 也支持 ap。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>10，Sentinel</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>是面向分布式服务的高可用防护组件，主要以流量为切入点，从流量控制，熔断降级，系统自适应保护等多个维度解决微服务的稳定性！
优势：
1，友好的控制面板，支持实时监控。
2，多种限流，支持QPS限流，线程限流，多种限流策略。
3，多种降级模式，支持按平均返回时间降级，按异常数，异常比例降级。
4，方便扩展开发，支持SPI模式对Chain会进行扩展。
5，支持链路的关联，按链路统计限流，系统保护，热门资源保护等等。
局限性：
	sentinel所有的统计都是基于QPS，也就是1s为单位，包括统计异常率，只是和大并发请求的场景，而Hystrix时间窗口可以设置。
	简单讲sentinel更加侧重于流量控制，hystrix更加灵活。

核心功能：
	1，实时监控平台。
	2，聚簇链路，针对一个业务功能查看其调用的链路节点信息
	3，流控规则：Sentinel可以针对调用者进行限流，填写微服务名，指定对哪个微服务进行限流 ，默认default(不区分来源，全部限制)。
	4，热点规则：流控规则的更细粒度操作，可以具体到对某个热点参数的限流，设置限流之后，如果带着限流参数的请求量超过阈值，则进行限流，时间为统计窗口时长。
	5，系统规则：从应用级别的入口流量进行控制，针对的是全局的系统。
	6，授权规则：根据调用方来判断该次请求是否放行，这时候可以使用Sentinel的来源访问控制功能。
	7，熔断规则：对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出DegradeException）。

流控效果：
快速失败
    直接失败
Warm Up
    预热/冷启动，也就是说预防瞬间大量的请求一下将服务器干死，设置后会给系统一段预热时间，使其缓缓的上升最大负载，如阈值10 预热时长五秒。那么就会在启动阶段的实际阈值时10/3，等到五秒后才会达到最大阈值10，如秒杀活动都是这样慢慢的放量进入
排队等待
    让请求以均匀的速度通过，阈值类型必须设成QPS，否则无效。简单来说，虽然我一只能一次处理一个请求但是在指定时间你不会失败，我一个一个处理，如果超过等待时间则请求失败。
 容错策略：

 慢调用比例
    当异常在统计时长内超过比例阈值，且请求数超过最小请求数，请求事件大于最大RT，则进入熔断时长，经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。

异常比例
    当请求数在单位统计时长内大于最小请求数，异常数大于设置的异常比例则进入熔断，熔断时长过后熔断器进入探测恢复状态，若下一个请求成功则结束熔断，失败继续熔断。

异常数
    当单位统计时长内的异常数超过阈值之后自动给进入熔断，熔断时长后进入探测状态，若下一个请求成功则结束熔断，失败继续熔断。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>143，Gateway网关</p> <p>Gateway网关的三大功能？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Route(路由)
    路由是构网关的基本模块,他由ID,目标URL,一系列的断言和过滤器组成,如果断言为true则匹配该路由
Predicate(断言)
    1,开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由
2,参考Java8的java.util.function.Predicate
Filter(过滤)
    指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由之前或者之后对请求进行修改

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="nginx"><a href="#nginx" class="header-anchor">#</a> Nginx</h3> <p>1，什么时Nginx？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>轻量级的高性能反向代理web服务器，高效实现反向代理，负载均衡，官方可以处理5万并发连接数；

优点： 内存小 高并发链接 实现http服务器，虚拟注解方向代理，负载均衡，配置简单，不暴露正式服IP地址
缺点：动态处理差，nginx处理静态文件比较好，动态处理页面很鸡肋

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>2，为什么用nginx？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>跨平台，配置简单，反向代理，高链接并发数，内存占用小 是个nginx才150M
nginx内置健康检查功能：如果有一个服务宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>3，nginx为什么性能这么高？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>异步非阻塞时间处理机制，运用了epoll模型，提供了一个队列，排队解决。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>4，Nginx如何处理请求过程？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>nginx接收一个请求后，首先由listen和server_name指令匹配server模块，再匹配server模块里的location，location就是实际地址。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>5，什么是正向代理，反向代理？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>正向代理就是一个人发送请求就直接到服务器。
反向代理就是由nginx接收，nginx收到后按照规则分发后端业务处理服务器进行处理。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>6，反向代理优点？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>7，如何用Nginx解决前端跨域问题？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>8，nginx虚拟主机怎么配置？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站
2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台
3、基于ip的虚拟主机。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>9，限流怎么做的？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>nginx限流就是限制用户请求速度，防止服务器受不了
限流由三种：Nginx的限流都是基于漏桶流算法
正常限制访问频率（正常流量）
突发限制访问频率（突发流量）
限制并发连接数

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>10，漏桶算法？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。
令牌桶算法：令牌桶算法的机制如下：存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直至装满整个令牌桶。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>11，Nginx负载均衡的算法怎么实现的?策略有哪些?</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>轮询：
权重：
ip_hash:

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>12，集群原理？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> Nginx集群其实是：虚拟主机+反向代理+upstream分发模块组成的。
  虚拟主机：负责接受和响应请求。
  反向代理：带领用户去数据服务器拿数据。
  upstream：告诉nginx去哪个数据服务器拿数据。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>13，数据走向（请求处理流程）</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    1）虚拟主机接受用户请求
  2）虚拟主机去找反向代理（问反向代理去哪拿数据）
  3）反向代理让去找upstream
  4）upstream告诉一个数据服务器IP
  5）Nginx去找数据服务器，并发起用户的请求
  6）数据服务器接受请求并处理请求
  7）数据服务器响应请求给Nginx
  8）Nginx响应请求给用户

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="es"><a href="#es" class="header-anchor">#</a> ES</h3> <p>什么是ES？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>java编写的，是基于Lucene的，RESUTful风格的搜索和数据分析引擎，能够达到实时搜索的速度，稳定可靠。
和solr总结：
es基本是开箱即用非常简单，solr安装复杂一点点。
es自带分布式协调管理，solr利用zookeeper进行分布式管理
solr支持更多格式，es支持json
solr官方提供的功能很多，es本身更注重核心功能，其他功能大多是第三方插件提供
es动态查询块，solr查询慢。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>1,ES写数据和读数据的过程</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>写数据
客户端选择一个协调节点发送求，后对docment进行路由转发给primary shard处理，然后将数据同步到replica node，协调节点发现primary shard 和 replica node处理完毕后响应客户端。

es读数据过程：
客户端选择一个协调节点发送过去后对docment进行路由转发对应node，使用随机轮询算在primary shard和所有的replica 中随机选择一个，让读请求负载均衡，接收请求的node节点返回document给协调节点。

es搜索数据过程：
2）协调节点将搜索请求转发到所有的shard对应的primary shard
3）每个shard将自己的搜索结果（其实就是一些doc id），返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果
4）接着由协调节点，根据doc id去各个节点上拉取实际的document数据，最终返回给客户端

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>2，elasticsearch 的倒排索引是什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>是通过分词策略形成了词和文章的映射关系表，这种词典+映射表就是倒排索引。有了倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了检索效率。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>3，elasticsearch 索引数据多了怎么办？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，才能避免数据激增导致集群处理能力不足，使得线上业务收到影响。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>4，elasticsearch 是如何实现 master 选举的？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>前提：只有候选主节点的节点才能成为主节点，最小主节点数的目的是防止脑裂。
第一步：确认候选主节点数达标，elasticsearch.yml 设置的值
第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；
若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>5，es集群三种颜色？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>红Red，表示有主分片没有分配，某些数据不可用。
黄色Yellow，表示主分片都已分配，数据都可用，但是有复制分片没有分配。
绿色Green，表示主分片和复制分片都已分配，一切正常。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>6，es节点</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>候选主节点:节点启动后，使用集群发现机制寻找集群中其他节点，并创建链接，集群中会从候选主节点中选举出一个主节点，主节点负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作。
数据节点：数据节点负责数据的存储和相关具体操作，比如CRUD、搜索、聚合。所以，数据节点对机器配置要求比较高，必须保证足够的磁盘空间存储数据。没选上主节点也可以做数据节点。
客户端节点:只负责请求的分发、汇总等等
协调节点：集群中的任何节点，都可以充当协调节点的角色。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></div> <div class="page-meta"><footer class="page-edit" style="margin:0;"><!----> <!----></footer> <div class="page-views" data-v-1a66a508><i class="fas fa-eye" data-v-1a66a508></i> <span class="view-count" data-v-1a66a508><span id="busuanzi_container_page_pv" style="display: none;" data-v-1a66a508>
            阅读次数: <span id="busuanzi_value_page_pv" data-v-1a66a508>0</span></span></span></div></div> <!----></div> <div class="toc-container-sidebar"><div class="pos-box"><div class="icon-arrow"></div> <div class="scroll-box" style="max-height:86vh"><div style="font-weight:bold;">java面试题</div> <hr> <div class="toc-box"><ul class="toc-sidebar-links"><li><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#redis" class="toc-sidebar-link">Redis</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#mybatis" class="toc-sidebar-link">Mybatis</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#spring" class="toc-sidebar-link">Spring</a><ul class="toc-sidebar-sub-headers"></ul></li><li><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#springboot" class="toc-sidebar-link">SpringBoot</a><ul class="toc-sidebar-sub-headers"><li class="toc-sidebar-sub-header"><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#springmvc" class="toc-sidebar-link">SpringMVC</a></li><li class="toc-sidebar-sub-header"><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#security" class="toc-sidebar-link">Security</a></li><li class="toc-sidebar-sub-header"><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#微服务" class="toc-sidebar-link">微服务</a></li><li class="toc-sidebar-sub-header"><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#nginx" class="toc-sidebar-link">Nginx</a></li><li class="toc-sidebar-sub-header"><a href="/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/Java%E7%9B%B8%E5%85%B3/java%E9%9D%A2%E8%AF%95%E9%A2%98%20c0447a99a77445e49b6ce257046024d5.html#es" class="toc-sidebar-link">ES</a></li></ul></li></ul></div></div></div></div></div>  <main class="footer"> <div class="copy-right"><a target="_blank" rel="noreferrer">
              
            </a></div></main></main> <aside class="page-sidebar"> <div class="page-side-toolbar"></div>  </aside></div><div class="global-ui"><div></div><!----></div></div>
    <script src="/assets/js/app.ca6810f0.js" defer></script><script src="/assets/js/1.a7899151.js" defer></script><script src="/assets/js/76.aaca7275.js" defer></script>
  </body>
</html>
