(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{410:function(s,a,n){"use strict";n.r(a);var t=n(4),e=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("C++智能指针是一种封装了原始指针的类，用于自动管理动态分配的内存，以避免内存泄漏。\nC++标准库（STL）中提供了三种主要的智能指针：st\n"),a("code",[s._v("d::unique_ptr")]),s._v("、"),a("code",[s._v("std::shared_ptr")]),s._v("和"),a("code",[s._v("std::weak_ptr")]),s._v("，每种智能指针都有其特定的用途和管理策略。")]),s._v(" "),a("h2",{attrs:{id:"正常指针释放过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正常指针释放过程"}},[s._v("#")]),s._v(" 正常指针释放过程")]),s._v(" "),a("div",{staticClass:"language-c++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("MyClass* my_class = new MyClass();\nmy_class->classMethod();\ndelete my_class;\nmy_class = nullptr;\n//指针为null\nmy_class->classMethod();\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h2",{attrs:{id:"std-unique-ptr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#std-unique-ptr"}},[s._v("#")]),s._v(" std::unique_ptr")]),s._v(" "),a("p",[a("code",[s._v("std::unique_ptr")]),s._v("是一种独占所有权的智能指针。它保证同一时间只有一个unique_ptr可以指向给定的资源。\n当unique_ptr被销毁时（例如，当它超出作用域时），它指向的对象也会被自动删除。")]),s._v(" "),a("div",{staticClass:"language-c++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("#include <memory>\n\nclass MyClass {\npublic:\nMyClass() {}\nvoid classMethod() {}\n};\n\nint main() {\nstd::unique_ptr<MyClass> myPtr(new MyClass());\nmyPtr->classMethod(); // 使用智能指针访问成员函数\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h2",{attrs:{id:"std-shared-ptr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#std-shared-ptr"}},[s._v("#")]),s._v(" std::shared_ptr")]),s._v(" "),a("p",[s._v("std::shared_ptr是一种共享所有权的智能指针。多个shared_ptr可以指向同一个资源。\n资源只有在最后一个指向它的shared_ptr被销毁后才会被释放。\n这通过引用计数来实现，每次复制shared_ptr时计数增加，每次销毁时计数减少。")]),s._v(" "),a("div",{staticClass:"language-c++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("#include <memory>\n\nclass MyClass {\npublic:\nMyClass() {}\nvoid classMethod() {}\n};\n\nint main() {\nstd::shared_ptr<MyClass> myPtr1 = std::make_shared<MyClass>();\nstd::shared_ptr<MyClass> myPtr2 = myPtr1; // myPtr1和myPtr2共享所有权\nmyPtr2->classMethod();\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("h2",{attrs:{id:"std-weak-ptr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#std-weak-ptr"}},[s._v("#")]),s._v(" std::weak_ptr")]),s._v(" "),a("p",[a("code",[s._v("std::weak_ptr")]),s._v("是一种不控制对象生命周期的智能指针。\n它设计用来解决shared_ptr相互引用时可能导致的循环引用问题。\nweak_ptr需要与shared_ptr一起工作，通过weak_ptr可以观察但不延长shared_ptr管理的对象的生命周期。")]),s._v(" "),a("div",{staticClass:"language-c++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("#include <memory>\n\nclass MyClass {\npublic:\nstd::weak_ptr<MyClass> other; // 用weak_ptr解决潜在的循环引用问题\nMyClass() {}\nvoid classMethod() {}\n};\n\nint main() {\nstd::shared_ptr<MyClass> myPtr1 = std::make_shared<MyClass>();\nstd::shared_ptr<MyClass> myPtr2 = std::make_shared<MyClass>();\n\n    myPtr1->other = myPtr2;\n    myPtr2->other = myPtr1; // 创建一个循环引用\n\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("p",[s._v("通过使用智能指针，可以有效地管理动态分配的内存，避免内存泄漏，简化内存管理操作。智能指针还提供了一些额外的安全和便利特性，如自动资源释放、异常安全等。")])])}),[],!1,null,null,null);a.default=e.exports}}]);