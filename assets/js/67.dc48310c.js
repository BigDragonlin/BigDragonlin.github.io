(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{427:function(a,s,t){"use strict";t.r(s);var _=t(4),v=Object(_.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"java基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[a._v("#")]),a._v(" Java基础")]),a._v(" "),s("h1",{attrs:{id:"_1-自我介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-自我介绍"}},[a._v("#")]),a._v(" 1.自我介绍")]),a._v(" "),s("p",[a._v("面试官你好，我叫曹梦，今年25岁，之前在郑州做了一年开发，做过两个项目。主要的技术栈是springboot，mybatisplus,mysql,redis。也了解一些前端的技术，比如js，css，vue，小程序这些，会使用一些linux命令，docker")]),a._v(" "),s("h1",{attrs:{id:"_2-什么是面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是面向对象"}},[a._v("#")]),a._v(" 2.什么是面向对象")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("老师笔记")]),a._v(" "),s("p",[a._v("面向过程：拆解成每个步骤，一步一步来")]),a._v(" "),s("p",[a._v("面向对象：将洗衣拆成人和洗衣机，然后通过调用人.方法和洗衣机.方法 完成洗衣的动作。")]),a._v(" "),s("p",[a._v("面向过程更加注重步骤和顺序，它的性能比较强")]),a._v(" "),s("p",[a._v("面向对象，更加易于复用，更加易于拓展")]),a._v(" "),s("p",[a._v("面向对向的时候，必须要说封装继承多态")]),a._v(" "),s("p",[a._v("封装：内部细节对外部调用者不透明，拿来直接用，你不用管怎么实现。黑箱")]),a._v(" "),s("p",[a._v("继承：继承基类的方法，并对其进行改编。将共性的东西，抽离出来放到父类当中，这样可以达到代码复用")]),a._v(" "),s("p",[a._v("多态：多态有一个前提，就是要有继承，有方法重写，父类引用指向子类对象。")])])]),a._v(" "),s("h1",{attrs:{id:"_3-jdk-jre-jvm三者的联系和区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-jdk-jre-jvm三者的联系和区别"}},[a._v("#")]),a._v(" 3.JDK，JRE，JVM三者的联系和区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("老师笔记")]),a._v(" "),s("p",[a._v("jdk: java development kit 开发工具")]),a._v(" "),s("p",[a._v("jre: java runtime environment java运行环境")]),a._v(" "),s("p",[a._v("如果我们只是普通用户，我们只需要下载java运行环境就可以了。")]),a._v(" "),s("p",[a._v("包括bin文件，jvm的文件夹 和 lib文件，放类库的文件夹")]),a._v(" "),s("p",[a._v("jvm:java virtual machine")]),a._v(" "),s("p",[a._v("由jdk中的java工具javac编译成class文件。将.class文件放到jvm中")]),a._v(" "),s("p",[a._v("将class文件解释成为不同机器适配的机器码，从而实现一次开发，多种设备之间都可以运行")])])]),a._v(" "),s("h1",{attrs:{id:"_4-和equals"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-和equals"}},[a._v("#")]),a._v(" 4.==和equals")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("老师笔记")]),a._v(" "),s("p",[a._v("equals 如果不重写其实和==是一样的")]),a._v(" "),s("p",[a._v("== 是比较栈中存放的值，基本数据类型是变量值，引用类型的话比较引用的地址。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("string a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"hello world"')]),a._v("\nstring b "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" string "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"hello world"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v('//a 中的"hello world" 会放入堆中常量池')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//b中的内容会放在堆中非常量池")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//a 只是引用地址，放在栈中")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])])])]),a._v(" "),s("h1",{attrs:{id:"_5-谈谈你对-约定优于配置-的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-谈谈你对-约定优于配置-的理解"}},[a._v("#")]),a._v(" 5.谈谈你对”约定优于配置”的理解")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("自己总结")]),a._v(" "),s("p",[a._v("“约定优于配置”是一种软件设计范式，它指的是遵循一种约定俗称的范式去进行开发，这种开发模式降低了开发人员的工作量，增强了代码的可读性，又不失一定的灵活性。")]),a._v(" "),s("p",[a._v("许多框架都有约定优于配置的理念在其中，比如maven")])])]),a._v(" "),s("h1",{attrs:{id:"_6-简述final的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-简述final的作用"}},[a._v("#")]),a._v(" 6.简述final的作用；")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("final可以修饰类，变量，方法")]),a._v(" "),s("p",[a._v("修饰类表示这个类是太监类，不能被继承，也不能够被实现，所以接口不能够被使用。")]),a._v(" "),s("p",[a._v("修饰变量，表示一旦变量被赋值，就没办法再修改值。修饰基本数据类型，一旦final之后就无法更改，修饰引用数据类型，引用的地址不能改变，但是它的值可以改变。")]),a._v(" "),s("p",[a._v("修饰方法，不能够被重写，但是可以被重载")])])]),a._v(" "),s("h1",{attrs:{id:"_7-为什么局部内部类和匿名内部类只能访问局部final的变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-为什么局部内部类和匿名内部类只能访问局部final的变量"}},[a._v("#")]),a._v(" 7.为什么局部内部类和匿名内部类只能访问局部final的变量")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("test03")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("run")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("start")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])])])]),a._v(" "),s("p",[a._v("使用匿名内部类和局部内部类编译出来的字节码文件有两个，一个是主体的字节码文件，另外一个就是内部类。当主体字节码文件执行被垃圾回收之后，内部类没有办法获得类变量，所以它在之前就会cope一份类变量给自己，但是类变量有可能会变，所以使用final修饰类变量。")]),a._v(" "),s("h1",{attrs:{id:"_8-string-stringbuilder-stringbuffer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-string-stringbuilder-stringbuffer"}},[a._v("#")]),a._v(" 8.String,StringBuilder,StringBuffer")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("String 的每一次修改都会new一个新对象，如果这个变量修改比较频繁的话，那么就会比较浪费空间。")]),a._v(" "),s("p",[a._v("stringbuilder是线程不安全的")]),a._v(" "),s("p",[a._v("stringbuffer它的方法都被"),s("code",[a._v("synchronized")])]),a._v(" "),s("p",[a._v("速度")]),a._v(" "),s("p",[a._v("stringbuilder>stringbuffer>string")]),a._v(" "),s("p",[a._v("经常改变字符的我们用stringbuffer和stringbuiler")]),a._v(" "),s("p",[a._v("优先使用stringbuiler，多线程的时候使用stringbuffer")])])]),a._v(" "),s("h1",{attrs:{id:"_9-泛型中extends和super的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-泛型中extends和super的区别"}},[a._v("#")]),a._v(" 9.泛型中extends和super的区别")]),a._v(" "),s("ol",[s("li",[a._v("\n<?extends T>表示包含T在内的任何T的子类\n")]),a._v(" "),s("li",[a._v("\n<? super T>表示包括T在内任何T的父类 \n")])]),a._v(" "),s("p",[a._v("我们使用getClass没有办法获取方法的泛型，泛型擦除。")]),a._v(" "),s("h1",{attrs:{id:"_10-重载、重写的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-重载、重写的区别"}},[a._v("#")]),a._v(" 10.重载、重写的区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("重载：")]),a._v(" "),s("p",[a._v("发生在同一个类当中，方法名相同，参数类型，数量必须不同。")]),a._v(" "),s("p",[a._v("重写")]),a._v(" "),s("p",[a._v("发生在子类中，子类继承父类，重写方法，方法名必须相同，参数列表必须相同，返回值和抛出异常小于等于父类，访问修饰符大于等于父类，privite修饰的不能被重写。")])])]),a._v(" "),s("h1",{attrs:{id:"_11-接口和抽象类的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-接口和抽象类的区别"}},[a._v("#")]),a._v(" 11.接口和抽象类的区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("接口设计的目的是为了方法的有无")]),a._v(" "),s("p",[a._v("抽象类设计的目的是为了实现接口的复用")])])]),a._v(" "),s("h1",{attrs:{id:"_12-list和set的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-list和set的区别"}},[a._v("#")]),a._v(" 12.List和Set的区别")]),a._v(" "),s("ul",[s("li",[a._v("总结\n"),s("ul",[s("li",[s("p",[a._v("List")]),a._v(" "),s("p",[a._v("有序列表，按照对象进入的顺序储存对象，可以重复，可以有多个null存，可以使用iteretor逐一存，使用get取。使用interater遍历")])]),a._v(" "),s("li",[s("p",[a._v("Set")]),a._v(" "),s("p",[a._v("无序列表，不可重复，最多有一个null存，使用interater遍历")])])])])]),a._v(" "),s("h1",{attrs:{id:"_13-arraylist和linkedlist区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-arraylist和linkedlist区别"}},[a._v("#")]),a._v(" 13.ArrayList和LinkedList区别")]),a._v(" "),s("ul",[s("li",[a._v("笔记\n"),s("ul",[s("li",[a._v("首先，他们的底层数据结构是不一样的，ArryList是数组，LinkList就是基于链表实现的。数组更加适合查找，链表更加适合添加删除。")]),a._v(" "),s("li",[a._v("由于底层数据结构不同，他们适用的场景也就不同，ArryList更加适合随机查找，LinkList更加适合删除和添加，查询、添加、删除的时间复杂度不同。")]),a._v(" "),s("li",[a._v("另外ArryList和LinkList实现List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当成队列使用")])])])]),a._v(" "),s("h1",{attrs:{id:"_14-hashcode和equals区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-hashcode和equals区别"}},[a._v("#")]),a._v(" 14.hashCode和equals区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("笔记")]),a._v(" "),s("p",[a._v("hashCode源自于object类，所有的类都默认继承这个类，所以所有的类都可以使用这个方法。")]),a._v(" "),s("p",[a._v("hashCode方法指向实例化对象在堆中的hash地址，可以用这个方法来看你实例化后的对象是不是一个对象。比如我们创建string对象，我们使用hashcode方法来打印他的地址，然后修改对象，再用hashcode打印，发现他们两个打印的地址是不一样的。new stringbuilder或者string buffer，发现他们打印的是一样的。")]),a._v(" "),s("p",[a._v("equals如果不重写的话，它和==是一样的，都是比较对象的地址，如果重写的话，一般都会比较对象的值。")])])]),a._v(" "),s("h1",{attrs:{id:"_15-hashmap和hashtable的区别和底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-hashmap和hashtable的区别和底层实现"}},[a._v("#")]),a._v(" 15.HashMap和HashTable的区别和底层实现")]),a._v(" "),s("p",[a._v("HashMap和HashTable他们实现的接口和继承的方法都一样，但是HashTable的返回值使用Sycronized修饰，说明它是线程安全的，HashMap线程是不安全的。HashMap在多线程情况下，有可能执行结果会出现不一样，HashTable则不会有这个问题。")]),a._v(" "),s("p",[a._v("HashMap允许key和value为null，而HashTable则不允许")]),a._v(" "),s("p",[a._v("底层实现：数组加链表实现")]),a._v(" "),s("h1",{attrs:{id:"_16-如何实现一个ioc容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-如何实现一个ioc容器"}},[a._v("#")]),a._v(" 16.如何实现一个IOC容器")]),a._v(" "),s("ol",[s("li",[a._v("配置文件，配置包扫描路径")]),a._v(" "),s("li",[a._v("递归包扫描  .class文件")]),a._v(" "),s("li",[a._v("反射，确定需要较为ioc管理的类")]),a._v(" "),s("li",[a._v("对需要注入的类进行依赖注入")])]),a._v(" "),s("ul",[s("li",[a._v("配置文件中需要扫描的路径")]),a._v(" "),s("li",[a._v("定义一些注解，业务服务层，数据持久层，依赖注入层，获取配置文件注解")]),a._v(" "),s("li",[a._v("从配置文件中获取要扫描的包路径，获取到当前文件信息及文件夹信息，将所有这些包下面的.class文件都放到set集合中存。")]),a._v(" "),s("li",[a._v("便利这个集合，获取这些集合上面有指定注释的类，把它交给ioc容器，定义一个安全的map来存这些对象")]),a._v(" "),s("li",[a._v("遍历整个ioc容器，获取每一个类上面的实例，判断里面有没有依赖其它类的实例，然后进行递归注入。")])]),a._v(" "),s("h1",{attrs:{id:"_17-什么是字节码-采用字节码的好处是什么。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-什么是字节码-采用字节码的好处是什么。"}},[a._v("#")]),a._v(" 17.什么是字节码？采用字节码的好处是什么。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[s("a",{attrs:{href:"http://xn--ide-db9dr2ahzy1i27fe81bba0874c5caq78m.java",target:"_blank",rel:"noopener noreferrer"}},[a._v("我们使用ide编写之后生成.java"),s("OutboundLink")],1),a._v(" 文件要经过javac编译，编译之后的文件就是字节码。")]),a._v(" "),s("p",[a._v("由jvm 通过解释器将.class文件解释为特定系统的机器码，")]),a._v(" "),s("p",[a._v("采用字节码的好处是，一次编译，处处运行。")]),a._v(" "),s("p",[a._v("java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可以移植的特点。所以java语言运行起来比较高效，而且由于字节码并不转对于某一种特定的机器，所以java无需重新编译便可在多种不同的计算机上运行。")])])]),a._v(" "),s("h1",{attrs:{id:"_18-java类加载器有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-java类加载器有哪些"}},[a._v("#")]),a._v(" 18.java类加载器有哪些")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("JDK自带的三个类加载器：boostrap ClassLoad（顶层的类加载器），ExtClassLoader,AppClassLoad")]),a._v(" "),s("p",[a._v("boostrap ClassLoad是ExtClassLoader的父加载器，默认负载加载%java_home%lib下的jar包和class文件")]),a._v(" "),s("p",[a._v("ExtClassLoader是AppClassLoad父类加载器，负责加载%java_home%lib/ext文件夹下的jar包和class类，AppClassLoad是自定义加载器的父类，负载加载classpath下的类文件。系统类加载器，线程上下文加载器。")])])]),a._v(" "),s("h1",{attrs:{id:"_19-双亲委派模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-双亲委派模型"}},[a._v("#")]),a._v(" 19.双亲委派模型")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("parents delegate 父委托，上溯委托")]),a._v(" "),s("p",[s("img",{staticClass:"lazy",attrs:{alt:"Untitled","data-src":"Java%E5%9F%BA%E7%A1%80%20672320c7a2234ca1bac271e681f17e31/Untitled.png",loading:"lazy"}})]),a._v(" "),s("p",[a._v("先说几个类加载器")]),a._v(" "),s("p",[a._v("向上委派就是查找类加载缓存，如果缓存中有，就返回。向下查找就是查找类加载路径。向上委派委派到bootstarpClassLoad,向下查找查找到自定义类加载器。")]),a._v(" "),s("p",[a._v("好处：")]),a._v(" "),s("p",[a._v("安全性：")]),a._v(" "),s("p",[a._v("自己写的类和jdk冲突的时候，不会加载你自己写的类。")]),a._v(" "),s("p",[a._v("不仅仅是根据你写的类的全路径，还会根据哪个类加载器")])])]),a._v(" "),s("h1",{attrs:{id:"_20-java中的异常体系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-java中的异常体系"}},[a._v("#")]),a._v(" 20.java中的异常体系")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("Java中所有的异常都来自Throwable")]),a._v(" "),s("p",[a._v("Throwable下有两个子类exception（能够处理和干预的）和error（程序无法处理 OOM（内存溢出））")]),a._v(" "),s("p",[a._v("Excepton不会导致程序终止（nullException），分为RuntimeException（运行时异常）和CheckedException检查异常，编译时就会发现。")])])]),a._v(" "),s("h1",{attrs:{id:"_21-gc如何判断对象可以被回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-gc如何判断对象可以被回收"}},[a._v("#")]),a._v(" 21.GC如何判断对象可以被回收")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("引用计数法")]),a._v(" "),s("p",[a._v("每一个对象都有一个引用计数器，新增一个引用时计数器+1，引用释放时计数-1，计数为0的时候可以回收。")]),a._v(" "),s("p",[a._v("引用计数法容易产生循环引用，会导致相互引用的的方法永远不能被回收。")])]),a._v(" "),s("li",[s("p",[a._v("可达性分析法：（java使用）")]),a._v(" "),s("p",[a._v("从GCRoot开始向下搜索，当一个对象到GCRoot没有任何引用链相连的时候，那么这个对象和与之相关联的对象就可以被GC回收。")]),a._v(" "),s("p",[a._v("GCRoot的对象有：")]),a._v(" "),s("ul",[s("li",[a._v("虚拟机栈（栈帧中的本地变量表）中引用的对象。")]),a._v(" "),s("li",[a._v("方法区中类静态属性引用的对象。")]),a._v(" "),s("li",[a._v("方法区中常量引用的对象")]),a._v(" "),s("li",[a._v("本地方法栈中中的JNI（一般说的Native方法）引用的对象")])]),a._v(" "),s("p",[a._v("可达性算法中的不可达对象不是立即死亡的，对象被系统宣告死亡至少要经历两次标记过程：第一次分析时经过可达性分析发现没有与GCRoot相连接的引用链，第二次是由虚拟机自动简历的finalizer队列中判断是否需要执行")]),a._v(" "),s("p",[a._v("finalize（）方法。")])])]),a._v(" "),s("h1",{attrs:{id:"_22-线程的生命周期和线程的状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-线程的生命周期和线程的状态"}},[a._v("#")]),a._v(" 22.线程的生命周期和线程的状态")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("线程有五种状态，创建，就绪，运行，阻塞和死亡")]),a._v(" "),s("p",[a._v("阻塞分为三种：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("等待阻塞：运行的线程执行wait（）方法，该线程会释放占用的所有的资源，包括锁资源。jvm会把线程放到等待池之中，进入这个状态之后，是不能被唤醒的，必须依靠其它线程调用notify或者notifyAll（）方法才能被唤醒，wait时objece类的方法。")])]),a._v(" "),s("li",[s("p",[a._v("同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。")])]),a._v(" "),s("li",[s("p",[a._v("其它阻塞：运行的线程执行sleep或join（）方法，或者发出了I/O请求，jvm会把该线程设置为阻塞状态。当sleep状态超时、join等待线程结束或者超时、或者I/O处理完毕时，线程重新转入就绪状态，sleep时Thread类方法")])]),a._v(" "),s("li",[s("p",[a._v("新建状态（New）：新建一个线程对象。")])]),a._v(" "),s("li",[s("p",[a._v("就绪状态（Runable）：线程对象创建好后")])])])])]),a._v(" "),s("h1",{attrs:{id:"_23-说一下hashmap的put方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_23-说一下hashmap的put方法"}},[a._v("#")]),a._v(" 23.说一下HashMap的Put方法")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("先说hashmap的put方法的具体流程")]),a._v(" "),s("ol",[s("li",[a._v("拿到key，根据hash算法的与运算拿到数组下标")]),a._v(" "),s("li",[a._v("如果当前数组下标为空，那么将这个key和value封装成entry对象（1.7为entry对象，1.8为node对象）并放到该位置。")]),a._v(" "),s("li",[a._v("如果数组下标位置不为空\n"),s("ol",[s("li",[a._v("如果是jdk1.7的话，它会先判断要不要扩容，如果要扩容，它就扩容，如果它不要扩容，那么就不用扩容，生成entry对象通过头插法插入到当前链表中。")]),a._v(" "),s("li",[a._v("如果为红黑树node，如果这个红黑树上面没有要添加的node，那么就把这个node添加到红黑树当中，如果有有当前的key，那么就更新value。")]),a._v(" "),s("li",[a._v("如果是jdk1.8的话，会先去判断node类型，是红黑树node还是链表node。\n"),s("ol",[s("li",[a._v("如果当前node是链表node的话，通过尾插法将node添加到链表尾部，在添加的过程中，将会遍历整个链表，如果这个时候链表中有key，那么更新value,在更新完之后，如果整个链表的长度大于等于8的话，整个链表转为红黑树")]),a._v(" "),s("li",[a._v("将node插入到链表或者红黑树之后，判断是否需要扩容，如果要扩容，就对其进行扩容，如果不需要就结束put方法。")])])])])])])])]),a._v(" "),s("h1",{attrs:{id:"_24-jdk1-7到jdk1-8-hashmap发生了什么变化-底层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_24-jdk1-7到jdk1-8-hashmap发生了什么变化-底层"}},[a._v("#")]),a._v(" 24.jdk1.7到jdk1.8 HashMap发生了什么变化（底层）？")]),a._v(" "),s("ul",[s("li",[a._v("总结\n"),s("ol",[s("li",[a._v("1.7中底层时数组+链表。1.8底层时数组+链表+红黑树，加红黑树的目的是为了提高hashmap插入和查询的效率。")]),a._v(" "),s("li",[a._v("1.7中链表插入使用的是头插法，1.8中链表使用的是尾插法。")]),a._v(" "),s("li",[a._v("1.7中哈希算法比较复杂，使用了很多的右移与互运算，1.8中进行了简化，因为复杂的哈希算法的目的是提高了散列性，提高hashmap的整体效率，而1.8中新增了红黑树，所以可以适当降低哈希算法的复杂性，提高程序的整体运行效率。")])])])]),a._v(" "),s("h1",{attrs:{id:"_25-谈谈concurrenthashmap的扩容机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_25-谈谈concurrenthashmap的扩容机制"}},[a._v("#")]),a._v(" 25.谈谈ConcurrentHashMap的扩容机制")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("1.8版本")]),a._v(" "),s("ol",[s("li",[a._v("扩容之前先对要扩容的数组进行分组，然后通过不同线程来进行转移，每个线程负责一块的工作。")]),a._v(" "),s("li",[a._v("扩容之前先生成一个新数组")]),a._v(" "),s("li",[a._v("1.8版本的concurrentHashMap不再基于segment实现")]),a._v(" "),s("li",[a._v("当某个线程put时发现concurrentHashMap正在扩容的时候，它会帮忙过来一起扩容。")]),a._v(" "),s("li",[a._v("如果某个线程put时没有发现concurrentHanshmap在扩容，则将key-value添加到concurrentHashmap，然后判断concurrentHashmap要不要扩容，如果要的话，就对它进行扩容。")]),a._v(" "),s("li",[a._v("concurrentHashMap支持多个线程一起扩容")])]),a._v(" "),s("p",[a._v("1.7版本")]),a._v(" "),s("ol",[s("li",[a._v("基于segment分段来实现")]),a._v(" "),s("li",[a._v("每个segment相当于一个小型的hashmap")]),a._v(" "),s("li",[a._v("每个segmet内部都会扩容，和hashmap扩容逻辑形似")]),a._v(" "),s("li",[a._v("先生成新的数组，然后转移数组到新的数组当中")]),a._v(" "),s("li",[a._v("扩容的判断也是每个segment内部判断的，判断是否超过阈值")])])])]),a._v(" "),s("h1",{attrs:{id:"_26-深拷贝和浅拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_26-深拷贝和浅拷贝"}},[a._v("#")]),a._v(" 26.深拷贝和浅拷贝")]),a._v(" "),s("ul",[s("li",[a._v("总结\n"),s("ul",[s("li",[a._v("浅拷贝 浅拷贝拷贝基本数据类型的值，还有引用数据类型的地址。")]),a._v(" "),s("li",[a._v("深拷贝 深拷贝拷贝基本数据类型的值，引用数据类型的所有。")])])])]),a._v(" "),s("h1",{attrs:{id:"_27-hashmap的扩容机制原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_27-hashmap的扩容机制原理"}},[a._v("#")]),a._v(" 27.HashMap的扩容机制原理")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("1.7版本")]),a._v(" "),s("ol",[s("li",[a._v("先生成新数组")]),a._v(" "),s("li",[a._v("遍历老数组中的每个位置上的链表上的每一个元素")]),a._v(" "),s("li",[a._v("去每一个元素的key，并基于新数组的长度，给每一个元素计算下标")]),a._v(" "),s("li",[a._v("将元素添加到新数组上去")]),a._v(" "),s("li",[a._v("所有元素转移完之后，将新数组赋值给hashmap中的table属性")])]),a._v(" "),s("p",[a._v("1.8版本")]),a._v(" "),s("ol",[s("li",[a._v("先生成新数组")]),a._v(" "),s("li",[a._v("遍历老数组中的链表或者红黑树")]),a._v(" "),s("li",[a._v("如果是链表，将链表中元素的下标通过hash运算添加到新数组中")]),a._v(" "),s("li",[a._v("如果是红黑树，计算红黑树中每个元素在新数组的下标\n"),s("ol",[s("li",[a._v("统计每个下标位置的元素数")]),a._v(" "),s("li",[a._v("如果元素数超过了8，则生成一个新的红黑树，并且将根节点添加到新数组的对应位置。")]),a._v(" "),s("li",[a._v("如果没有超过8，则生成一个链表，将链表的头节点添加到新数组的对应位置。")])])]),a._v(" "),s("li",[a._v("所有元素转移完之后，将新数组赋值给hashmap中的table属性")])])])]),a._v(" "),s("h1",{attrs:{id:"_28-什么时候抛出异常-什么时候捕获异常"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_28-什么时候抛出异常-什么时候捕获异常"}},[a._v("#")]),a._v(" 28.什么时候抛出异常，什么时候捕获异常")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("能够处理就处理，不能够处理就抛出去。")])])]),a._v(" "),s("h1",{attrs:{id:"_29-说说对线程安全的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_29-说说对线程安全的理解"}},[a._v("#")]),a._v(" 29.说说对线程安全的理解")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("线程安全的意思就是，多个线程执行一段程序，结果不会出现混乱。比如i=0，两个线程同时执行i++，正常情况下，一个结果时1，另外一个结果时2，这个时候我们可以说这这段代码时线程安全的。如果两个线程的结果都为1，则表示这段代码是线程不安全的。")]),a._v(" "),s("p",[a._v("线程安全指的是同一段代码被同时执行，能否得到正确的结果。")])])]),a._v(" "),s("h1",{attrs:{id:"说说对守护线程的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说说对守护线程的理解"}},[a._v("#")]),a._v(" 说说对守护线程的理解")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("线程分为守护线程和用户线程，用户线程就是普通线程，守护线程就是jvm的后台线程，守护线程会在其它普通线程都关闭之后自动关闭，我们可以通过thread.setdaemon（）来把普通线程设置为守护线程。")])])]),a._v(" "),s("h1",{attrs:{id:"threadlocal的底层原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal的底层原理"}},[a._v("#")]),a._v(" ThreadLocal的底层原理")]),a._v(" "),s("ul",[s("li",[a._v("总结\n"),s("ol",[s("li",[a._v("ThreadLocal是java提供的线程本地储存技术，可以利用该机制将数据缓存到线程内部，该线程可以在任意时刻，任意位置获取缓存的数据。")]),a._v(" "),s("li",[a._v("ThreadLocal通过ThreadLocalMap实现，每一个Thread对象（不是Thread对象）都存在一个ThreadLocalMap，Map的key是ThreadLoacl对象，map的值是缓存的值。")]),a._v(" "),s("li",[a._v("如果使用完ThreadLocal之后，一定要把ThreadLocal的值回收，如果不回收，有可能导致内存泄漏，解决的办法就是获取完ThreadLocal对象之后，进行remove")])])])]),a._v(" "),s("h1",{attrs:{id:"并发、并行、串行之间的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发、并行、串行之间的区别"}},[a._v("#")]),a._v(" 并发、并行、串行之间的区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("总结")]),a._v(" "),s("p",[a._v("并发：")]),a._v(" "),s("p",[a._v("程序在一个系统中运行，每一个时刻只有一个线程在使用")]),a._v(" "),s("p",[a._v("并行：")]),a._v(" "),s("p",[a._v("程序在一个系统中运行，所有线程一起执行")]),a._v(" "),s("p",[a._v("串行：")]),a._v(" "),s("p",[a._v("程序在一个系统中运行，按照顺序执行，前面没有执行完，后面不能执行")])])])])}),[],!1,null,null,null);s.default=v.exports}}]);