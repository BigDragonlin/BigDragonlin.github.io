(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{462:function(a,t,i){"use strict";i.r(t);var r=i(7),n=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"spring相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring相关"}},[a._v("#")]),a._v(" Spring相关")]),a._v(" "),t("h1",{attrs:{id:"spring是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring是什么"}},[a._v("#")]),a._v(" Spring是什么")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("总结")]),a._v(" "),t("p",[a._v("轻量级的开源的J2EE框架，它是一个容器框架，用来装javaBean，中间层框架（万能胶），可以起到一个连接功能。")]),a._v(" "),t("p",[a._v("spring是一个轻量级的控制反转（ioc）和面向切面编程（aop）的容器框架")]),a._v(" "),t("ul",[t("li",[a._v("从大小和开销来说，spring来说都是轻量级的。对代码侵入性比较低")]),a._v(" "),t("li",[a._v("通过ioc方式来实现松耦合")]),a._v(" "),t("li",[a._v("提供面向切面编程对的丰富支持，允许分析应用的业务逻辑与系统服务进行内聚性开发")]),a._v(" "),t("li",[a._v("包含并管理应用对象（bean）的配置和生命周期，这个意义上spring是一个容器")]),a._v(" "),t("li",[a._v("可以将简单的组件配置，组合成复杂的应用，这个意义上是一个框架。")])])])]),a._v(" "),t("h1",{attrs:{id:"对aop的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对aop的理解"}},[a._v("#")]),a._v(" 对Aop的理解")]),a._v(" "),t("p",[a._v("系统由不同的组件组成，每一个组件各负责一块特定的功能。除了实现自身的核心功能之外，它还要承担其它的功能，比如打日志，处理异常。这些系统服务称之为横切关注点，它会跨越很多组件。")]),a._v(" "),t("p",[a._v("oop，一步一步来，我们每一个异常都要新建对象，重复代码太多代码太多，不利于各个模块测重用。oop允许你定义从上到下的关系，但是不允许你定义从左到右的关系。")]),a._v(" "),t("p",[a._v("aop，将程序的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体的业务逻辑）中。aop可以对某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前做一些额外的事情，在执行某个方法之后做一些额外的事情。")]),a._v(" "),t("h1",{attrs:{id:"对ioc的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对ioc的理解"}},[a._v("#")]),a._v(" 对IOC的理解")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("总结")]),a._v(" "),t("p",[a._v("容器概念、控制反转、依赖注入")]),a._v(" "),t("p",[a._v("ioc是干什么？ioc是容器，用来存放java对象，存放到map，xml配置的bean，bean中的实例对象。使用di注入，来使用对象。")]),a._v(" "),t("p",[a._v("控制反转,没有引入ioc之前，在a类new b，在运行a中，我们要主动的new b，控制权在a对象中。引入ioc对象之后，a和b就不会关联，a和b都放到ioc容器当中，如果这个时候a要用到bean对象，ioc容器这个时候会主动创建b对象注入到a中，对象和对象这个时候就不用再关联了。")]),a._v(" "),t("p",[a._v("依赖注入，这个东西是为了实现控制反转。我们创建a对象，和a对象所依赖的b对象放到ioc容器中，当ioc容器使用a对象的时候要b对象，这个时候容器就把b对象给a对象，这个过程就叫做依赖注入。由a对象自己new出来到容器给a对象。")])])]),a._v(" "),t("h1",{attrs:{id:"单例bean和单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例bean和单例模式"}},[a._v("#")]),a._v(" 单例Bean和单例模式")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("总结")]),a._v(" "),t("p",[a._v("单例模式表示jvm中某个类型的bean只会存一在唯一一个。")]),a._v(" "),t("p",[a._v("单例bean并不表示jvm中只存在唯一的某个类的对象。")]),a._v(" "),t("p",[a._v("spring默认是singleton，不是prototype")])])]),a._v(" "),t("h1",{attrs:{id:"beanfactory和applicationcontext有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory和applicationcontext有什么区别"}},[a._v("#")]),a._v(" BeanFactory和ApplicationContext有什么区别")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("总结")]),a._v(" "),t("p",[a._v("BeanFactory是spring中非常重要的组件，表示bean工厂，可以生成bean，维护bean，而ApplicationContext继承了BeanFactory，所以ApplicationContext拥有Bean所有的特点，也是一个Bean工厂，但是ApplicationContext除了继承BeanFactory之外，还继承了MessageSource（国际化），EnvironmentCapable（环境变量）之类的接口")])])]),a._v(" "),t("h1",{attrs:{id:"简述spring-bean的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简述spring-bean的生命周期"}},[a._v("#")]),a._v(" 简述Spring Bean的生命周期")]),a._v(" "),t("ul",[t("li",[a._v("总结\n"),t("ol",[t("li",[a._v("解析类，（用@ComponentScan扫描）得到BeanDefinition")]),a._v(" "),t("li",[a._v("如果有多个构造方法，则需要推断构造方法")]),a._v(" "),t("li",[a._v("确定好构造方法之后，进行实例化得到一个对象（bean对象）")]),a._v(" "),t("li",[a._v("对对象中加@Autowired注解的属性进行属性填充")]),a._v(" "),t("li",[a._v("回调Aware方法，比如BeanNameAware，BeanFactoryAware")]),a._v(" "),t("li",[a._v("调用BeanPostProcessor的初始化前的方法")]),a._v(" "),t("li",[a._v("调用初始化方法")]),a._v(" "),t("li",[a._v("调用BeanPostProcessor初始化方法，在这里会完成aop")]),a._v(" "),t("li",[a._v("如果当前创建的bean是单例的，就会把bean放到单例池")]),a._v(" "),t("li",[a._v("使用bean")]),a._v(" "),t("li",[a._v("spring容器关闭时调用DisposableBean中Destory方法")])])])]),a._v(" "),t("h1",{attrs:{id:"spring支持几种bean的作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring支持几种bean的作用域"}},[a._v("#")]),a._v(" Spring支持几种Bean的作用域")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("总结")]),a._v(" "),t("ul",[t("li",[a._v("默认时singleton模式，也就是单例模式，单例模式由BeanFactory自身来维护，该对象的生命周期是和ioc容器时一样的（但在第一次注入的时候才会被创建）")]),a._v(" "),t("li",[a._v("prototype：为每一个bean提供一个实例，在每次注入的时候会创建一个新对象")]),a._v(" "),t("li",[a._v("request：bean被定义为每一次request请求就创建一个实例，request请求完成后，实例将会被回收。")]),a._v(" "),t("li",[a._v("session和request类似。")]),a._v(" "),t("li",[a._v("application：bean被定义到serverletContext生命周期中复用一个单例对象")]),a._v(" "),t("li",[a._v("websocket：bean被定义为websocket生命周期中复用的一个单例对象。")])]),a._v(" "),t("p",[a._v("globlesession：全局作用域。")])])]),a._v(" "),t("h1",{attrs:{id:"spring事务的实现方式和隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring事务的实现方式和隔离级别"}},[a._v("#")]),a._v(" Spring事务的实现方式和隔离级别")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("总结")]),a._v(" "),t("p",[a._v("实现：")]),a._v(" "),t("p",[a._v("string主要通过两种方式来实现事务，一种时编程式事务，一种是声明式事务。编程式事务很少用，主要是用声明式事务，在用事务的方法上，添加注解transactional ，然后再启动类上添加enabletransational。")]),a._v(" "),t("p",[a._v("如果spring再设置事务隔离级别，跟spring")]),a._v(" "),t("p",[a._v("隔离级read commited：读已提交。产生问题两次读取结果不一致，叫做不可重复读。 不可重复读解决了脏读问题，他只会读取已经提交了的事务。")]),a._v(" "),t("ul",[t("li",[a._v("repeatable read：可重复读，mysql默认隔离级别，事务开启禁止update操作，只能insert操作。每次读取结果都一样，但是有可能产生幻读。")]),a._v(" "),t("li",[a._v("serializable：串行化，一般不适用，它给每一行读取的数据加锁，效率太低。")])])])]),a._v(" "),t("h2",{attrs:{id:"精髓-面试题-讲一下springboot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#精髓-面试题-讲一下springboot"}},[a._v("#")]),a._v(" 精髓（面试题）讲一下springboot")]),a._v(" "),t("p",[a._v("1、SpringBoot启动会加载大量的自动配置类")]),a._v(" "),t("p",[a._v("2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；")]),a._v(" "),t("p",[a._v("3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）")]),a._v(" "),t("p",[a._v("4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；")]),a._v(" "),t("p",[a._v("**xxxxAutoConfigurartion：自动配置类；**给容器中添加组件")]),a._v(" "),t("p",[t("strong",[a._v("xxxxProperties:封装配置文件中相关属性；")])]),a._v(" "),t("h1",{attrs:{id:"说一下springboot-springboot自动装配原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一下springboot-springboot自动装配原理"}},[a._v("#")]),a._v(" 说一下springboot，springboot自动装配原理")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("总结")]),a._v(" "),t("p",[a._v("1.springboot的主启动类在@springbootapplication里面")]),a._v(" "),t("p",[a._v("2.springboot在启动之后会通过@springbootapplication下的@enableautoconfigration加载大量的自动配置类")]),a._v(" "),t("p",[a._v("3.@spirngbootapplicion下面有组件扫描包扫描我们项目中使用了哪些组件")]),a._v(" "),t("p",[a._v("4.如果springbootautoconfigration下面有自动配置，我们就不用自动配置了")])])]),a._v(" "),t("h1",{attrs:{id:"如何理解springboot的starter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何理解springboot的starter"}},[a._v("#")]),a._v(" 如何理解springboot的starter")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("总结")]),a._v(" "),t("p",[a._v("Start就是一个jar包，写入一个@Configuration配置类，将这些bean定义在其中，然后在start包中的meta-inf/spring.factories中写入配置类，那么springboot程序在启动的时候会加载此配置类。")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);